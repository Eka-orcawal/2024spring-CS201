# 数算编程汇总

## week1

### 20742: 泰波拿契數

http://cs101.openjudge.cn/practice/20742/

思路与感想：从第四个数（T3）开始，之后的数都是前三个数相加，将最后三个数字相加得到的数放在下一位，依次类推出Tn及之前的数，最后输出Tn，这种相加需进行（n-2）次，即想得到第四个数（n=3）只需要加1（3-2）次。这道题让我记起了考场上对不齐角标的恐慌……尤其学了R之后，总要迟疑一下第n个角标是n还是n-1。

##### 代码

```python
# http://cs101.openjudge.cn/practice/20742/
n=int(input())
T=[0,1,1]
if n>=3:
    for i in range(n-2):
        T.append(T[i]+T[i+1]+T[i+2])
print(T[n])
```

代码运行截图 

![image-20240226200908564](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226200908564.png)

### 58A. Chat room

greedy/strings, 1000, http://codeforces.com/problemset/problem/58/A

思路与感想：本题曾在去年计概时AC过，当时采用了答案的解法，这次用作复习。总体思路是，保证某个字母出现之前，前边的字母都按次序出现过并标记，如果次序不按单词顺序就要去掉所有标记重新检索标记。

##### 代码

```python
# http://codeforces.com/problemset/problem/58/A
w=input()
h=0
e=0
l1=0
l2=0
o=0
for i in range(len(w)):
    if w[i]=='h':
        h=1
    elif w[i]=='e' and h==1:
        e=1
        h=0
    elif w[i]=='l' and e==1:
        l1=1
        e=0
    elif w[i]=='l' and l1==1:
        l2=1
        l1=0
    elif w[i]=='o' and l2==1:
        o=1
        
if o==1:
    print("YES")
else:
    print("NO")

```

代码运行截图 

![image-20240226203537019](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226203537019.png)

### 118A. String Task

implementation/strings, 1000, http://codeforces.com/problemset/problem/118/A

思路与感想：也是曾经AC过的题，先将所有字母都转换为小写，再筛出非元音字母，输出时可以用循环，也可以用join()将一整个列表都输出。要注意中间分隔符不能是空格。

例如去年使用了：

```python
print('.',end="")
print('.'.join(wordout))
```

##### 代码

```python
#  http://codeforces.com/problemset/problem/118/A
word=list(input().lower())
string=["a",'o','u','e','y','i']
wordout=[]
for i in range (len(word)):
    if word[i] not in string:
        wordout.append(word[i])
for i in range(len(wordout)):
    print('.',end="")
    print(wordout[i],end="")
```

代码运行截图

![image-20240226204334909](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226204334909.png)

### 22359: Goldbach Conjecture

http://cs101.openjudge.cn/practice/22359/

思路与感想：找到n之前的所有素数（余数不为零），定住素数A之后判断n-A是否也是素数，如果是，则n-A就是素数B，输出A和B即可。比较简单的一题，一遍过。

（大概翻了一下提交统计，好像达成了目前最短AC代码的成就？瞬间自信起来了（bushi））

##### 代码

```python
# http://cs101.openjudge.cn/practice/22359/
n=int(input())
prime=[]

for i in range(2,n-1):
    if (n%i)!=0:
        prime.append(i)
    else:
        continue

for pri in prime:
    if (n-pri) in prime:
        print(pri,n-pri)
    break
```

代码运行截图

![image-20240226222104508](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226222104508.png)

### 23563: 多项式时间复杂度

http://cs101.openjudge.cn/practice/23563/

思路与感想：字符串形如“ax^b+ax^b+……ax^b”将字符串分割两次得到a和b，补全1n，去掉0n，选出其中最大的b，输出“n^”和b即可。这道题总觉得似曾相识，好像是在某次月考中做到过，但是并没有找到笔记，很奇怪，熟悉的陌生题。

##### 代码

```python
# http://cs101.openjudge.cn/practice/23563/
n=(input().split("+"))
Omax=0
for i in range(len(n)):
    n[i]=n[i].split("n^")
    
    if n[i][0]=="":
        n[i][0]="1"
    elif n[i][0]=="0":
        n[i][1]="0"
    
    n[i][1]=int(n[i][1])
    if n[i][1]>=Omax:
        Omax=n[i][1]
print("n^",Omax,sep="")
```

代码运行截图 

![image-20240226231626891](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226231626891.png)

### 24684: 直播计票

http://cs101.openjudge.cn/practice/24684/

思路与感想：使用字典计数，找到票数最多的序号，排序输出序号。由于当年没好好学字典，遇到题都是硬套列表，所以完全没有字典的语法基础，还在考场上因为角标对不齐吃了大亏，今天就在字典语法上花了些时间，最后的join()直接“搬运”了我以前的代码——字符串转换为int再转回来——将字符串转换为int，这样在排序时就不会出现问题；join()只能用于字符串，所以排序后一定要再转换回字符串。

##### 代码

```python
# http://cs101.openjudge.cn/practice/24684/
n=list(input().split())
ndict={}
for i in range(len(n)):    
    if ndict.get(n[i]) is not None:
        x=ndict[n[i]]
        x+=1
        ndict.update({n[i]:x})
    else:
        ndict[n[i]]=1
maxvalue=max(ndict.values())
maxlist=[]
for i,j in ndict.items():
    if j==maxvalue:
        maxlist.append(int(str(i)))   
print(" ".join('%s' %id for id in sorted(maxlist)))
```

代码运行截图 

![image-20240226215929793](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240226215929793.png)

### 感想：

在计概中拿到了较为理想的成绩后，就根据专业需要将学习重点转向了R语言，所以在做这次作业之前已经有整整一年没有接触过python了。这次作业中虽然有几道题是曾经做过的，但时隔一年再次打开oj等网站已经算得上是“手生”，甚至语法也混淆了，很多函数经常不用已经不记得格式是什么样的了，所以这次在语法上花了较多时间。之后大概会给自己定一个每天练习的小目标，争取不做ddl战士。第一周的作业完成较快，代码基本能一次AC（吃的唯一一个WA是因为忘记删掉测试的那一行输出），思路也很顺。但因为语法生疏，用了差不多三个小时，从机考的角度来看还是得多多练习呀。

## Week2

### 27653: Fraction类

http://cs101.openjudge.cn/practice/27653/

思路：先按照分数的运算法则算出未化简的分子分母，再寻找分子分母的最大公因数约分。如果直接用for循环一个一个找会Runtime Error，所以使用了辗转相除法：用较大数m除较小数n，若能整除则最大公约数就是较小数。若有余数r，则用较小数除余数，直到整除。最后一步的较小数就是所求的最大公因数。

这道题第一次尝试超时，毫不意外。

##### 代码

```python
# http://cs101.openjudge.cn/practice/27653/
a1,b1,a2,b2=map(int,input().split())
a=a1*b2+a2*b1
b=b1*b2
if a==b:
    print("1")
else:
    m=max(a,b)
    n=min(a,b)
    r=m%n
    while r!=0:#辗转相除法求最大公因数
        m=n
        n=r
        r=m%n

    print(a//n,"/",b//n,sep="")
```

代码运行截图 

![image-20240229120712827](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240229120712827.png)

### 04110: 圣诞老人的礼物-Santa Clau’s Gifts

greedy/dp, http://cs101.openjudge.cn/practice/04110

思路：由于可以随意拆分，所以不存在装不满的情况，找出单价最高的糖果优先装箱即可

##### 代码

```python
#  http://cs101.openjudge.cn/practice/04110
n,w=map(int,input().split())
danjia=[]

for i in range(n):
    zongjia,xiangshu=map(int,input().split())
    for j in range(xiangshu):
        danjia.append(zongjia/xiangshu)
danjia.sort()
danjia.reverse()#最大单价在前
print('%.1f'%sum(danjia[:w]))
```

代码运行截图

![image-20240229121842022](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240229121842022.png)

### 18182: 打怪兽

implementation/sortings/data structures, http://cs101.openjudge.cn/practice/18182/

思路：先将所有输入的技能用字典储存起来，然后按照时间顺序优先输出伤害最高的技能。这个题以前也做过，按照以前的思路过了一遍，字典确实很好用。

##### 代码

```python
#http://cs101.openjudge.cn/practice/18182/
nCases=int(input())
for Casse in range(nCases):
    n,m,b=map(int,input().split())
    ns={}
    for i in range(n):#将每刻对应的所有技能伤害存在dict中
        ti,xi=map(int,input().split())
        if ti in ns:
            ns[ti].append(xi)
        else:
            ns[ti]=[xi]
    times=sorted(ns)#有技能的时刻
    ending=0
    for time in times:
        if m>=len(ns[time]):#可释放数量>=技能数量时不用排序
            b-=sum(ns[time])
        else:
            ns[time].sort()
            ns[time].reverse()
            b-=sum(ns[time][0:m])#优先输出最高伤害的技能
        if b<=0:
            print(time)
            break
    if b>0:
        print("alive")
```

代码运行截图

![image-20240229124723328](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240229124723328.png)

### 230B. T-primes

binary search/implementation/math/number theory, 1300, http://codeforces.com/problemset/problem/230/B

思路：素数的平方就是T-prime，所以先是创建列表来判断是否为质数，最后注意1的特殊情况就可以。判断质数的方法是从以前的AC题解找来的，欧拉筛还是那么的“不明觉厉”，在纸上演算了几遍搞懂了机制。

##### 代码

```python
#  http://codeforces.com/problemset/problem/230/B，欧拉筛，找到prime
n=int(input())
x=list(map(int,input().split()))
pri=[True]*1000001
for i in range (1,500001):
    if pri[i]:
        for j in range(i,1000001,i+1):
            pri[j]=False
            pri[i]=True
for i in range(len(x)):#判断T-prime
    if x[i]==1:
        print("NO")
    elif x[i]**0.5%1==0:
        num=int(x[i]**0.5)
        
        if pri[num-1]:
            print("YES")
        else:
            print("NO")
    else:
        print("NO")
```

代码运行截图

![image-20240301212414133](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240301212414133.png)

### 1364A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A

思路：使用两个循环嵌套，将之间的数字加起来判断余数，但是显然会超时，果不其然收获了n个Time limit exceeded on test 3。

一开始的代码如下，结果倒是对的，但两个循环嵌套且每层都有判断导致用时爆炸：

```python
t=int(input())
for i in range(t):
    n,x=map(int,input().split())
    xs=list(map(int,input().split()))
    am=[-1]
    for j in range(n):
        for y in range(j,n+1):
            if j==y and xs[j]%x!=0:
                am.append(1)
            elif(sum(xs[j:y]))%x!=0:
                am.append(y-j)
            elif j==0 and y==n and sum(xs)%x!=0:
                am.append(n)
    print(max(am))
```

尝试减少运算次数，但是改代码一小时无果。中间尝试先将所有数字转换为余数，但是总想着每次求sum，所以还是离不开循环嵌套（看到答案解法豁然开朗了，其实根本不需要每次求sum）。加上本人不是很会双指针，双指针写了一半写晕乎了……太菜了，大晚上心态炸了，第二天起来再写orz）

最后因为耗时太多，选择看答案，发现有一个思路和我很像的解法——首先是判断所有余数之和是否能被x除尽，若不能，则直接输出整个列表的长度；若能，从两端开始向中间掐（减少了一半循环次数，因为用or来判断两头），只要出现了一个非0数，就说明从这一位开始，”能被整除“的状态就被破坏了。这个数字在前在后不重要，也不需要分情况讨论，只需要知道这个”距离两头的最近的非零余数“的距离减掉就可以了。

（等下也看看双指针怎么搞，先交作业防止错过ddl）

##### 代码

```python
#https://codeforces.com/problemset/problem/1364/A
t=int(input())
for i in range(t):
    n,x=map(int,input().split())
    xs=list(map(lambda y: int(y)%x,input().split())) 
    #直接运算余数，要用lambda定义一个运算
    am=-1
    if sum(xs)%x: #True说明sum余数不能被整除，即符合题意，直接输出
        print(n)
        continue
    for j in range(n//2+1):
        if xs[j] or xs[~j]:   #说明能被整除的状态被破坏
            am=n-j-1         #减去“距离两头最近的非0余数”
            break
    print(am)
```

代码运行截图

![image-20240302153204352](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240302153204352.png)

### 18176: 2050年成绩计算

http://cs101.openjudge.cn/practice/18176/

思路：（看完题目的第一感受：控分大佬）先照搬一下230B中的方法（知道欧拉筛的话这一题应该不是很难）。

##### 代码

```python
# http://cs101.openjudge.cn/practice/18176/
#欧拉筛和T-prime（同230B）
pri=[True]*10001
for i in range (1,5001):
    if pri[i]:
        for j in range(i,10001,i+1):
            pri[j]=False
            pri[i]=True
m,n=map(int,input().split())           
for _ in range(m):
    x=list(map(int,input().split()))
    mark=0
    for i in range(len(x)):#直接将非T-p项改成0
        if x[i]==1 :
            x[i]=0
        elif x[i]**0.5%1==0:
            num=int(x[i]**0.5)
            if not pri[num-1]:
                x[i]=0
        else:
            x[i]=0
    
    mark=max(mark,sum(x)/len(x))
    if mark==0:#0不能有小数位，所以直接输出
        print(mark)
    else:
        print("{:.2f}".format(mark))#转换为字符串输出小数点后两位
        #print("%.2f"%mark) ⬅也可以用这个语法
```

代码运行截图

![image-20240302162500409](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240302162500409.png)

### 感想：

群内大佬云集，我在其中格格不入……感觉，自己还是太菜了orz。代码越打越晕，算法稍微复杂一些就不会做了。

究其原因，可能是因为一直以来我都偏好用数学方法“偷懒”（因为算法太差了，只能寄希望于数学化简问题，而过度依赖数学方法导致算法的熟练度也没提升orz死循环了），这就导致有的时候思路一卡死就钻进死胡同出不来了，想换算法但是不会用，就比如这次的XXXXX。

本次作业耗时比较长，被”超时“卡住的时候能感觉得到技巧性的东西越来越多，而不是能跑出来正确的output就行。希望自己能保持住学习的动力叭！

1364A其他解法（尝试ing）

```python
t = int(input())
for i in range(t):
    n,x=map(int,input().split())
    xs=list(map(int,input().split()))
    maxlen=-1
    xsum=0
    left=0
for right in range(n):
    xsum += xs[right]
    while left <= right and xsum%x!= 0:
        maxlen=max(right-left+1,maxlen)
        xsum-=xs[left]
        left+=1
print(maxlen)
```

## **Week3**



Updated 1537 GMT+8 March 6, 2024

2024 spring, Complied by ==靳咏歌 城市与环境学院==

**说明：**

The complete process to learn DSA from scratch can be broken into 4 parts:

- Learn about Time and Space complexities
- Learn the basics of individual Data Structures
- Learn the basics of Algorithms
- Practice Problems on DSA

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### **02945: 拦截导弹**

http://cs101.openjudge.cn/practice/02945/

思路：dp，要找到每个导弹后最多能有几个一连串比它高度低的，所以每个dp[i]要选择在它之后最大的dp[j]+1。

##### 代码

```python
# http://cs101.openjudge.cn/practice/02945/
k=int(input())
x=list(map(int,input().split()))
dp=[0]*k
for i in range(k-1,-1,-1):
    maxn=1
    for j in range(k-1,i,-1):
        if x[i]>=x[j]:
            maxn=max(maxn,dp[j]+1)
    dp[i]=maxn    
print(max(dp))
```

代码运行截图 

![image-20240307171452325](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240307171452325.png)

### **04147:汉诺塔问题(Tower of Hanoi)**

http://cs101.openjudge.cn/practice/04147

思路：直接去看了题下面给的参考，这是一道阅读理解题（确信）看懂递归的逻辑就很容易

##### 代码

```python
#http://cs101.openjudge.cn/practice/04147
# 将编号为numdisk的盘子从init杆移至desti杆
def moveOne(numDisk : int, init : str, desti : str):
    print("{}:{}->{}".format(numDisk, init, desti))

#将numDisks个盘子从init杆借助temp杆移至desti杆
def move(numDisks : int, init : str, temp : str, desti : str):
    if numDisks == 1:
        moveOne(1, init, desti)
    else: 
        # 首先将上面的（numDisk-1）个盘子从init杆借助desti杆移至temp杆
        move(numDisks-1, init, desti, temp) 
        
        # 然后将编号为numDisks的盘子从init杆移至desti杆
        moveOne(numDisks, init, desti)
        
        # 最后将上面的（numDisks-1）个盘子从temp杆借助init杆移至desti杆 
        move(numDisks-1, temp, init, desti)

n, a, b, c = input().split()
move(int(n), a, b, c)
```

代码运行截图

![image-20240307170123069](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240307170123069.png)

### **03253: 约瑟夫问题No.2**

http://cs101.openjudge.cn/practice/03253

思路：按顺序弹出到一个输出列表里就行，开始因为看错了题浪费了很多时间……

（AC的第一道题……）

##### 代码

```python
# http://cs101.openjudge.cn/practice/03253
while True:
    n,p,m=map(int,input().split())
    if n==0:
        break
    children_out=[]
    num=list(range(1,n+1))
    for i in range(p-1):
        tmp=num.pop(0)
        num.append(tmp)
    count=0
    while num:
        tmp=num.pop(0)
        count+=1
        if count==m:
            count=0
            children_out.append(tmp)
            continue
        num.append(tmp)       

    print(",".join(map(str,children_out)))
```

代码运行截图 

![image-20240307164801705](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240307164801705.png)

### **21554:排队做实验 (greedy)v0.2**

http://cs101.openjudge.cn/practice/21554

思路：让用时短的人先做实验就能使时间最短

##### 代码

```python
#http://cs101.openjudge.cn/practice/21554 
n=int(input())
T=list(map(int,input().split()))
sum_time=0
Time=[]
timelist=[]
for i in range(n):      
    timelist.append([T[i],i+1])
timelist=sorted(timelist)
waitinglist=[x[1] for x in timelist]
for i in range(n):
    sum_time+=timelist[i][0]
    Time.append(sum_time) 
sum_waiting=sum(Time)-sum(T)

print(" ".join("%s" %id for id in waitinglist))
print("%.2f"%(sum_waiting/n))
```

代码运行截图 

![image-20240310214943750](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240310214943750.png)

### **19963:买学区房**

http://cs101.openjudge.cn/practice/19963

思路：进行两次排序比较大小即可，比较麻烦的是数据的接收

##### 代码

```python
# http://cs101.openjudge.cn/practice/19963
n=int(input())
xy=[tuple(map(int, pair.strip("()").split(","))) for pair in input().split()]
prices=list(map(int,input().split()))
houseratio=[[],[]]
ratios=[]
for i in range(n):
    ratio=(xy[i][0]+xy[i][1])/prices[i]
    ratios.append(ratio)
    houseratio[0].append(ratio)
    houseratio[1].append(prices[i])
midratio=[]
for i in range(2):
    sqeue=sorted(houseratio[i])
    if n%2==1:
        mid=(sqeue[n//2])
    else:
        mid_right=n//2
        mid_left=mid_right-1
        mid=(sqeue[mid_left]+sqeue[mid_right])/2
    midratio.append(mid)
output=0
for i in range(n):
    if houseratio[0][i]>midratio[0] and houseratio[1][i]<midratio[1] :
        output+=1
print(output)
```

代码运行截图

![image-20240311112908831](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240311112908831.png)

### **27300: 模型整理**

http://cs101.openjudge.cn/practice/27300

思路：这题主要麻烦在语法上，借鉴了答案里的处理方法，在每一个参数量的后边缀一个数字，用来作比较。

##### 代码

```python
# http://cs101.openjudge.cn/practice/27300
n=int(input())
modeldict={}
for i in range(n):
    modelname,modelquantity=(input().split("-"))
    if modelquantity[-1]=="M":							#用元组添加参数量的后缀
        modelquantity=(modelquantity,float(modelquantity[:-1])/1000)
    else:
        modelquantity=(modelquantity,float(modelquantity[:-1]))
    if modelname in modeldict:
        modeldict[modelname].append(modelquantity)
    else:
        modeldict[modelname]=[modelquantity]
    
names=sorted(modeldict)
for name in names:
    modeldict[name]=sorted(modeldict[name],key=lambda x:x[1])#排序依据是参数量的后缀
    print(name,": ", ', '.join([x[0]for x in modeldict[name]]),sep="")

```

代码运行截图 

![image-20240310224133660](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240310224133660.png)

### 感想



==如果作业题目简单，有否额外练习题目，比如：OJ“2024spring每日选做”、CF、LeetCode、洛谷等网站题目。==

## week4



Updated 0005 GMT+8 March 11, 2024

2024 spring, Complied by  靳咏歌 城市与环境学院

**说明：**

1）The complete process to learn DSA from scratch can be broken into 4 parts:

Learn about Time complexities, learn the basics of individual Data Structures, learn the basics of Algorithms, and practice Problems.

2）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

3）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

4）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 05902: 双端队列

http://cs101.openjudge.cn/practice/05902/

思路：创建一个列表，判断是根据要求判断是从末尾弹出还是从头弹出，即：pop()或者pop(0)。本来有点担心超时，但是很简单就通过了。(最容易的一道题)

代码：

```python
# http://cs101.openjudge.cn/practice/05902/
t=int(input())
for i in range(t):
    n=int(input())
    ns=[]
    for i in range(n):
        typen,xc=map(int,input().split())
        if typen==1:
            ns.append(xc)
        elif typen==2 and xc==1:
            ns.pop()
        else:
            ns.pop(0)
    if len(ns)!=0: 
        print(" ".join("%s" %id for id in ns))
    else:
        print("NULL")
```

代码运行截图

![image-20240317110721060](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240317110721060.png)

### 02694: 波兰表达式

http://cs101.openjudge.cn/practice/02694/

思路：经典题目，使用了stack，逆向弹出运算符号和数字。另外看了题解中的递归做法，很有意思。

题解递归：

```python
#2021fall-cs101，李文梁
s = input().split()
def cal():
    cur = s.pop(0)
    if cur in "+-*/":
        return str(eval(cal() + cur + cal()))
    else:
        return cur
print("%.6f" % float(cal()))
```

代码

```python
# http://cs101.openjudge.cn/practice/02694/
Str=reversed(input().split())
stack=[]
for _ in Str:
    if _ in "+-*/":
        x1=stack.pop()
        x2=stack.pop()
        stack.append(str(eval(x1+_+x2)))
    else:
        stack.append(_)
print("%6f" %float(stack[0]))
```

代码运行截图 

![image-20240317140206638](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240317140206638.png)

### 24591: 中序表达式转后序表达式

http://cs101.openjudge.cn/practice/24591/

思路：使用stack，自己写得很晕，所以去看了题解（代码开始长起来了orz）

代码

```python
# http://cs101.openjudge.cn/practice/24591/
def infix_to_postfix(expression):
    precedence = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    postfix = []
    number = ''

    for char in expression:
        if char.isnumeric() or char == '.':
            number += char     #构建出数字
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                #整数转换为int，否则是浮点数
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:
                    postfix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())  #弹出括号中间的运算符号
                stack.pop() #弹出'('

    if number:         #最后一个数字
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)

    while stack:       #弹出所有剩余的运算符号
        postfix.append(stack.pop())

    return ' '.join(str(x) for x in postfix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_postfix(expression))
```

代码运行截图（部分）

![image-20240317145834606](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240317145834606.png)

### 22068: 合法出栈序列

http://cs101.openjudge.cn/practice/22068/

思路：大概知道会和出栈的特性有关，但没看懂题意，所以直接去看题解了orz

重点是栈可以随进随出，只要output顺序中的字符和原字符进栈任意时候的栈顶匹配就弹出，直到原字符全部进过栈。（如果不匹配，可以等候后续字符继续进栈直到匹配，再看下一个output字符能否匹配。如果所有原字符都进过栈了，但output字符仍然匹配不上，说明没法按照这个顺序弹出。）

代码

```python
# http://cs101.openjudge.cn/practice/22068/
def valid_pop(origin,output):
    if len(origin)!=len(output):
        return False
    else:
        stack=[]
        ori=list(origin)
        for char in output:
            #将原字符按顺序推进栈，直到栈顶遇到output当前的char/全部推完
            while (not stack or stack[-1]!=char) and ori:               
                stack.append(ori.pop(0))
            # if stack[-1]==char
            #	stack.pop()
            #else:
            #	return False
            if  stack[-1]!=char #or not stack:
                return False    #原字符全部进栈时才会执行这一步，匹配不上，说明不合法（这里不用判断空栈，因为进行到这里，栈不可能为空，空栈说明所有字符都匹配弹出了）
            else: #只要在栈顶有char匹配，随时弹出,然后进下一轮
                stack.pop()            
        return True
origin=input()

while True:
    try:
        output=input()
        
        if valid_pop(origin,output):
            print("YES")
        else:
            print("NO")     
    except EOFError:
        break

```

代码运行截图

![image-20240318162612335](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240318162612335.png)

### 06646: 二叉树的深度

http://cs101.openjudge.cn/practice/06646/

思路：先构建出符合题意的树，然后递归到最大深度。树是照着题解学一步、走一步写出来的，结果缩进错行喜提WA（陷入自我怀疑，怎么有人照着写都能错orz）

代码

```python
# http://cs101.openjudge.cn/practice/06646/
class Treenode:
    def  __init__(self,x):
        self.val=x
        self.left=None
        self.right=None
def build_tree(nodelist):
    nodes={i:Treenode(i) for i in range(1,len(nodelist)+1)}
    for i,(nodeleft,noderight) in enumerate(nodelist,1):
        if nodeleft !=-1:
            nodes[i].left=nodes[nodeleft]
        if noderight !=-1:
            nodes[i].right=nodes[noderight]
    return nodes[1]

def max_depth(root):
    if root is None:
        return 0
    else:
        left_depth=max_depth(root.left)
        right_depth=max_depth(root.right)
        return max(left_depth,right_depth)+1

n=int(input())
nodelist=[]
for _ in range(n):
    nodeleft,noderight=map(int,input().split())
    nodelist.append((nodeleft,noderight))
    
root=build_tree(nodelist)
maxdepth=max_depth(root)

print(maxdepth)
```

代码运行截图 

![image-20240318150414816](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240318150414816.png)

### 02299: Ultra-QuickSort

http://cs101.openjudge.cn/practice/02299/

思路：感觉很不适应def的这种写法，看了题解和课件里的指针和快排。

代码

```python
# http://cs101.openjudge.cn/practice/02299/
def quicksort(arr):
    if len(arr)<=1:
        return arr,0
    mid=len(arr)//2 #将数字分为左右两组，分别排序
    left,swaps_left = quicksort(arr[:mid])#左右分别排序
    right,swaps_right = quicksort(arr[mid:])
    arr,swaps=merge(left,right) #两边加起来
    return arr,swaps+swaps_left+swaps_right 

def merge(left, right):
    i = j = 0 #分别给左右两半创建单指针
    merged=[] #排序后的列表
    swaps = 0 #交换计数
    while i < len(left) and j < len(right):#指针指到头之前
       if left[i] <= right[j]:
           merged.append(left[i])#将小的放在队列中，左边说明不用交换
           i += 1
       else:
           merged.append(right[j])#右边的更小，交换到左边并计数
           j += 1
           swaps += len(left)-i#每次只能相邻的交换
    merged += left[i:]#左边剩下的没有参与排序的
    merged += right[j:]#右边剩下的没有参与排序的
    return merged, swaps#返回排好的序列，交换次数
while True:
    n = int(input())
    if n == 0:
        break
    a = []
    for i in range(n):
        a.append(int(input()))
    a,steps= quicksort(a)
    print(steps)
```

代码运行截图 

![image-20240317210927393](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240317210927393.png)

### 学习总结和收获

代码越来越长了，以前不习惯用def，现在需要多多练起来了。

（及时总结前人经验不失为一种节约时间的方法，不能对着WA死耗）

## Week5



Updated 2124 GMT+8 March 17, 2024

2024 spring, Complied by  靳咏歌 城市与环境学院

**说明：**

1）The complete process to learn DSA from scratch can be broken into 4 parts:

Learn about Time complexities, learn the basics of individual Data Structures, learn the basics of Algorithms, and practice Problems.

2）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

3）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

4）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7



### 27638: 求二叉树的高度和叶子数目

http://cs101.openjudge.cn/practice/27638/

思路：叶子节点即没有子节点的节点，这一题需要判断出根的位置，使用一个状态列表判断出了根的位置。

代码

```python
# http://cs101.openjudge.cn/practice/27638/
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_depth(node):
    if node is None:
        return -1 #根据该题定义，空树高度为-1
    left_depth = tree_depth(node.left)
    right_depth = tree_depth(node.right)
    return max(left_depth, right_depth) + 1
	#return max(tree_depth(node.left),tree_depth(node.right))+1
def count_leaves(node):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        #判断叶子节点，没有左右儿子
        return 1
    return count_leaves(node.left) + count_leaves(node.right)

n = int(input())  # 读取节点数量
nodes = [TreeNode() for _ in range(n)]
has_parent=[False]*n #标记节点是否有父节点

for i in range(n):
    left_index, right_index = map(int, input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index]
        has_parent[left_index]=True
    if right_index != -1:
        nodes[i].right = nodes[right_index]
        has_parent[right_index]=True
#寻找根节点（没有父节点的节点）     
root_index=has_parent.index(False)
root = nodes[root_index] #从根开始建树
#计算高度和叶子节点数
depth= tree_depth(root)
leaves=count_leaves(root)
print(depth,leaves)
```

代码运行截图

![image-20240325133929342](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240325133929342.png)

### 24729: 括号嵌套树

http://cs101.openjudge.cn/practice/24729/

思路：每个字母都需要创建一个节点，可能不止有两个子节点所以用children[]列表来表示所有子节点。遇到左括号，就将当前节点推进栈，遇到字母如果有栈就放进栈顶节点的子节点中，遇到右括号则该节点结束，弹出该节点。前序是“根左右”，后序是“左右根”。

代码

```python
# http://cs101.openjudge.cn/practice/24729/
class TreeNode:
    def __init__(self, value): #类似字典
        self.value = value
        self.children = []

def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():  # 如果是字母，创建新节点
            node = TreeNode(char)
            if stack:  # 如果栈不为空，把节点作为子节点加入到栈顶节点的子节点列表中
                stack[-1].children.append(node)
        elif char == '(':  # 遇到左括号，当前节点可能会有子节点
            if node:
                stack.append(node)  # 把当前节点推入栈中
                node = None
        elif char == ')':  # 遇到右括号，子节点列表结束
            if stack:
                node = stack.pop()  # 弹出当前节点
    return node  # 根节点


def preorder(node):
    output = [node.value]
    for child in node.children:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output = []
    for child in node.children:
        output.extend(postorder(child))
    output.append(node.value)
    return ''.join(output)

# 主程序
def main():
    s = input().strip()
    s = ''.join(s.split())  # 去掉所有空白字符
    root = parse_tree(s)  # 解析整棵树
    if root:
        print(preorder(root))  # 输出前序遍历序列
        print(postorder(root))  # 输出后序遍历序列
    else:
        print("input tree string error!")

if __name__ == "__main__":
    main()
```

代码运行截图 

![image-20240325141606989](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240325141606989.png)

### 02775: 文件结构“图”

http://cs101.openjudge.cn/practice/02775/

思路：创建一个dir的类，每个dir中套有file和dir，每套一层加上一层的"|     "。从这一题了解到了*的用法，输出的时候很好用。

代码

```python
# http://cs101.openjudge.cn/practice/02775/
class dir:
    def __init__(self,dname):
        self.name=dname
        self.dirs=[]
        self.files=[]

    def getGraph(self):
        g = [self.name]
        for d in self.dirs: #dir内的需要套一层"|     "
            subg = d.getGraph()
            g.extend(["|     " + s for s in subg]) #给dir里的内容都加上"|     "
        for f in sorted(self.files): #当前目录files直接加
            g.append(f)
        return g

set_number=0
while True:
    set_number+=1
    stack=[dir("ROOT")]
    while (s:= input()) != "*":         #:=可以持续将输入用于判断
        if s=="#":
            break
        if s[0]=="f":
            stack[-1].files.append(s)   #将file归入当前目录
        elif s[0]=="d":
            stack.append(dir(s))
            stack[-2].dirs.append(stack[-1]) #将此dir连接到前一级目录
        else:
            stack.pop()   #检测到]之后回到上一级目录
    if s=="#":
        break
        
    print("DATA SET %d:"%set_number)
    print(*stack[0].getGraph(),sep='\n') #“*”将可迭代对象中的每个元素作为独立的参数传递给 print
    print()
```

代码运行截图 

![image-20240325145611636](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240325145611636.png)

### 25140: 根据后序表达式建立队列表达式

http://cs101.openjudge.cn/practice/25140/

思路：后序和队列表达式的转换关系

代码

```python
# http://cs101.openjudge.cn/practice/25140/
class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None
        
def build_tree(nodes):
    stack=[]
    for char in nodes:
        node=TreeNode(char)
        if char.isupper():
            node.right=stack.pop()
            node.left=stack.pop()
        stack.append(node)
    return stack[0]

def level_order_traversal(root):
    queue=[root]
    traversal=[]
    while queue:
        node=queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

n=int(input())
for _ in range(n):
    nodes=input()
    tree=build_tree(nodes)
    print(*reversed(level_order_traversal(tree)),sep="")
```

代码运行截图

![image-20240325223434974](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240325223434974.png)

### 24750: 根据二叉树中后序序列建树

http://cs101.openjudge.cn/practice/24750/

思路：后序是“左右根”，中序是“左根右”，前序是“根左右” ，搞清楚这个关系就能套出来

代码

```python
# http://cs101.openjudge.cn/practice/24750/
class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

#后序是“左右根”，中序是“左根右”，前序是“根左右”       
def buildTree(inorder,postorder):
    if not inorder or not postorder: #没有节点
        return None
    root_value=postorder.pop()
    root=TreeNode(root_value)   #后序的最后一个是当前的根节点，每次下沉都弹出一个
   
    root_index=inorder.index(root_value)
    
    root.right=buildTree(inorder[root_index+1:],postorder) 
    #中序根节点的右边就是右节点
    root.left=buildTree(inorder[:root_index],postorder)
    #中序根节点的左边就是左节点
    
    return root

def preorder(root): 
    result=[]
    if root:
        result.append(root.value)
        result.extend(preorder(root.left))
        result.extend(preorder(root.right))
    return result

inorder=input().strip()
postorder=input().strip()
root=buildTree(list(inorder), list(postorder)) 
print(*preorder(root),sep="")
```

代码运行截图

![image-20240325233708964](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240325233708964.png)

### 22158: 根据二叉树前中序序列建树

http://cs101.openjudge.cn/practice/22158/

思路：和24750一个逻辑，搞懂前中后序的遍历顺序就可以做出来

代码

```python
# http://cs101.openjudge.cn/practice/22158/
class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

#后序是“左右根”，中序是“左根右”，前序是“根左右”       
def buildTree(preorder,inorder):
    if not preorder or not inorder: #没有节点
        return None
    root_value=preorder.pop(0)
    root=TreeNode(root_value)   #前序的第一个是当前的根节点，每次下沉都弹出一个
   
    root_index=inorder.index(root_value)
    
    root.right=buildTree(preorder,inorder[root_index+1:]) 
    #中序根节点的右边就是右节点
    root.left=buildTree(preorder,inorder[:root_index])
    #中序根节点的左边就是左节点
    
    return root

def postorder(root): 
    result=[]
    if root:
        result.extend(postorder(root.left))
        result.extend(postorder(root.right))
        result.append(root.value)
    return result

while True:
    try:
        preorder=input().strip()
        inorder=input().strip()
        root=buildTree(list(preorder), list(inorder)) 
        print(*postorder(root),sep="")
    except EOFError:
        break
```

代码运行截图 

![image-20240326000937286](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240326000937286.png)

### 2. 学习总结和收获

改用def写程序后的最直观感受是：没法从变量栏看中间过程，没了可视化，感觉脑子要跟不上了……现在想写作业都要先一步步地看懂经典算法的代码才行，不然无从下手。好在，这六道题下来有了“顿悟”的感觉，基本搞明白“树”是怎么回事了，也体会到了数算“有模板可循”的特点。但stack的运用还不熟练，很容易晕。这次还从题解的写法学到了一些新东西，例如“*”和“:=”，感觉非常好用。

## week6



Updated 2214 GMT+8 March 24, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）这次作业内容不简单，耗时长的话直接参考题解。

2）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

3）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

4）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 22275: 二叉搜索树的遍历

http://cs101.openjudge.cn/practice/22275/

思路：二叉搜索树比较特殊的点在于节点值从小到大排序就是中序排列，所以这道题已知前序和中序，可以转换成”已知前中序求后序“

代码

```python
# http://cs101.openjudge.cn/practice/22275/
class TreeNode:
    def __init__(self,value):
        self.value=str(value)
        self.left=None
        self.right=None

#后序是“左右根”，中序是“左根右”，前序是“根左右”       
def buildTree(preorder,inorder):
    if not preorder or not inorder: #没有节点
        return None
    root_value=preorder.pop(0)
    
    root=TreeNode(root_value)   #前序的第一个是当前的根节点，每次下沉都弹出一个
    root_index=inorder.index(root_value)
    root.left=buildTree(preorder,inorder[:root_index])
    root.right=buildTree(preorder,inorder[root_index+1:]) 

    return root

def postorder(root):
    result=[]
    if root:
        result.extend(postorder(root.left))
        result.extend(postorder(root.right))
        result.append(root.value)
    return result

n=int(input())
preorder=list(map(int,input().split()))
inorder=sorted(preorder)
root=buildTree(preorder,inorder)
post=postorder(root)
print(*post,sep=" ")
```

代码运行截图

![image-20240331160908412](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240331160908412.png)

### 05455: 二叉搜索树的层次遍历

http://cs101.openjudge.cn/practice/05455/

思路：先去掉重复的数字（借用词典的key），从第一个数开始建树。对于后边的数，如果是空的就新建节点，如果有节点就先做比较，小了放左边，大了放右边。最后，按深度的顺序，从左到右依次输出节点。

代码

```python
# http://cs101.openjudge.cn/practice/05455/
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(node, value):
    if node is None:
        return TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left) #将下一深度的左节点放进去
        if node.right:
            queue.append(node.right)#将下一深度的右节点放进去
    return traversal

numbers=list(map(int,input().strip().split()))
numbers=list(dict.fromkeys(numbers))  # remove duplicates
root=None
for number in numbers:
    root=insert(root,number)
traversal = level_order_traversal(root)
print(*traversal,sep=" ")
```

代码运行截图 

![image-20240331170155094](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240331170155094.png)

### 04078: 实现堆结构

http://cs101.openjudge.cn/practice/04078/

练习自己写个BinHeap。当然机考时候，如果遇到这样题目，直接import heapq。手搓栈、队列、堆、AVL等，考试前需要搓个遍。

思路：直接看了课件，实现排序的那点太玄妙了

代码

```python
# http://cs101.openjudge.cn/practice/04078/
class BinHeap:
    def __init__(self):
        self.heaplist = [0]
        self.currentSize = 0
        
    def percUp(self, i):
        #大的在后
        while i//2>0:
            if self.heaplist[i] < self.heaplist[i//2]:
                tmp=self.heaplist[i//2]
                self.heaplist[i//2]=self.heaplist[i]
                self.heaplist[i]=tmp
            i=i//2
            
    def insert(self,k):
        self.heaplist.append(k)
        self.currentSize += 1
        self.percUp(self.currentSize)
    
    def percDowm(self,i):
        #小的在后
        while (i*2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heaplist[i]>self.heaplist[mc]:
                tmp=self.heaplist[i]
                self.heaplist[i]=self.heaplist[mc]
                self.heaplist[mc]=tmp
            i=mc
            
    def minChild(self,i):
        if i*2+1>self.currentSize:
            return i*2
        else:
            if self.heaplist[i*2]<self.heaplist[i*2+1]:
                return i*2
            else:
                return i*2+1
            
    def delMin(self):
        retval=self.heaplist[1]
        self.heaplist[1]=self.heaplist[self.currentSize]
        self.currentSize -= 1
        self.heaplist.pop()
        self.percDowm(1)
        return retval
    
    def buildHeap(self,alist):
        i=len(alist)//2
        self.currentSize=len(alist)
        self.heaplist=[0]+alist[:]
        while (i>0):
            #print(f'i={i},{self.heaplist}')
            self.percDowm(i)
            i -= 1
        #print(f'i={i},{self.heaplist}')

n=int(input().strip())
binheap=BinHeap()
for _ in range(n):
    typeint=input().strip()
    if typeint[0]=="1":
        u=int(typeint.split()[1])
        binheap.insert(u)
    else:
        print(binheap.delMin())
```

代码运行截图

![image-20240331212847532](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240331212847532.png)

### 22161: 哈夫曼编码树

http://cs101.openjudge.cn/practice/22161/

思路：将一串字符中权重最低的两个char聚在一起，得到新的权重再在剩余的char中排序，直到将所有的字符按照权重高低聚在一颗树上，权重越高距离根越进。然后再从根开始，每个左边的节点编号为0，右边的为1，就能只用0和1将这棵树上的所有char编码出来。利用堆来建树。

代码

```python
# http://cs101.openjudge.cn/practice/02524/
import heapq

class  Node:
    def __init__(self,weight,char=None):
        self.weight=weight
        self.left = None
        self.right = None
        self.char = char
    def __lt__(self,other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap=[]
    for char,weight in characters.items():
        heapq.heappush(heap,Node(weight,char))
        
    while len(heap)>1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left=left
        merged.right=right
        heapq.heappush(heap, merged)
    return heap[0]

def encode_huffman_tree(root): #进行编码
    codes={}
    def traverse(node,code):
        if node.left is None and node.right is None:
            codes[node.char] =code
        else: 
            traverse(node.left, code +"0")
            traverse(node.right,code+"1")
    traverse(root,"")
    return codes

def huffman_encoding(codes, string): #根据字符输出编码
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root,encoded_string): #根据编码输出字符
    decoded =""
    node = root
    for bit in encoded_string:
        if bit =="0":
            node = node.left
        else:
            node = node.right
        
        if node.left is None and node.right is None:
            decoded +=node.char
            node = root
    return decoded


n = int(input())
characters={}

for _ in range(n):
    char,weight =input().strip().split()
    characters[char]=int(weight)

huffman_tree= build_huffman_tree(characters) #建树
codes=encode_huffman_tree(huffman_tree) #编码

while True:
    try:
        inter=input().strip()
        if "0" in inter or "1" in inter:
            print(huffman_decoding(huffman_tree, inter))
        else:
            print(huffman_encoding(codes, inter))
    except EOFError:
        break
```

代码运行截图 

![image-20240401134023013](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240401134023013.png)

### 晴问9.5: 平衡二叉树的建立

https://sunnywhy.com/sfbj/9/5/359

思路：保证左右高度不超过1，左旋是将右子节点作为父节点，右旋是将左子节点作为父节点。对AVL树的旋转有了比较形象的理解。

代码

```python
# 
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.height = 1

class AVL:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root: #插入第一个节点
            self.root = Node(value)
        else:
            self.root = self._insert(value, self.root)

    def _insert(self, value, node): #插入后续节点
        if not node:
            return Node(value)
        elif value < node.value:
            node.left = self._insert(value, node.left)
        else:
            node.right = self._insert(value, node.right)

        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        balance = self._get_balance(node)

        if balance > 1: #树偏左
            if value < node.left.value:	# 树形是 LL
                return self._rotate_right(node)
            else:	# 树形是 LR
                node.left = self._rotate_left(node.left)
                return self._rotate_right(node)

        if balance < -1: #树偏右
            if value > node.right.value:	# 树形是 RR
                return self._rotate_left(node)
            else:	# 树形是 RL
                node.right = self._rotate_right(node.right)
                return self._rotate_left(node)

        return node

    def _get_height(self, node):
        if not node:
            return 0
        return node.height

    def _get_balance(self, node): #左height-右height
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)

    def _rotate_left(self, z): #左旋
        y = z.right
        T2 = y.left
        y.left = z
        z.right = T2
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        return y

    def _rotate_right(self, y): #右旋
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        x.height = 1 + max(self._get_height(x.left), self._get_height(x.right))
        return x

    def preorder(self): #先序遍历（中左右）
        return self._preorder(self.root)

    def _preorder(self, node):
        if not node:
            return []
        return [node.value] + self._preorder(node.left) + self._preorder(node.right)

n = int(input().strip())
sequence = list(map(int, input().strip().split()))

avl = AVL()
for value in sequence:
    avl.insert(value)

print(' '.join(map(str, avl.preorder())))
```

代码运行截图 

![image-20240401150348161](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240401150348161.png)

### 02524: 宗教信仰

http://cs101.openjudge.cn/practice/02524/

思路：并查集是和gpt老师学的，第一次提交喜提超时，应该是因为find()和union()用的递归比较多，所以从网上查了union()的优化方法，然后就没什么问题了。

代码

```python
#http://cs101.openjudge.cn/practice/02524/
class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.rank = [0] * (n + 1)
        self.count = n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x != root_y:
            if self.rank[root_x] < self.rank[root_y]:
                self.parent[root_x] = root_y
            elif self.rank[root_x] > self.rank[root_y]:
                self.parent[root_y] = root_x
            else:
                self.parent[root_y] = root_x
                self.rank[root_x] += 1
            self.count -= 1

case = 0
while True:
    case += 1
    n, m = map(int, input().strip().split())
    if n == m == 0:
        break

    students = DisjointSet(n)
    for _ in range(m):
        i, j = map(int, input().split())
        students.union(i, j)

    print("Case {}: {}".format(case, students.count))
```

代码运行截图

![image-20240401204819339](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240401204819339.png)

### 2. 学习总结和收获

学到这一周，二叉树好像是摸清楚了，但是实操熟练度还是不行，细节上老错。做作业很依赖题解，对于每一题关键的步骤总是缺少“灵感”，手搓堆、AVL、哈夫曼编码树之类的更是不敢想，直接看题解一行一行读代码（虽然能搞清楚逻辑，但是好难啊orz如果这些算法没有留成作业题，我可能直接放弃了）

## week 7

Updated 1557 GMT+8 Apr 3, 2024

2024 spring, Complied by  靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 27706: 逐词倒放

http://cs101.openjudge.cn/practice/27706/

思路：倒序后输出，但是这道题应该是想用栈，全部压进栈后再依次出栈（因为掐表做题所以先按最快的来了）

代码

```python
# http://cs101.openjudge.cn/practice/27706/
inter=list(input().split())
print(*reversed(inter),sep=" ")
```

代码运行截图

![image-20240408125935726](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408125935726.png)

### 27951: 机器翻译

http://cs101.openjudge.cn/practice/27951/

思路：记录压入列表的次数就是“查字典”的次数

代码

```python
# http://cs101.openjudge.cn/practice/27951/
M,N=map(int,input().split())
ns=list(map(int,input().split()))
stack=[]
times=0
for n in ns:
    if len(stack)==M and n not in stack:
        stack.pop(0)
    if n not in stack:
        stack.append(n)
        times+=1
print(times)
```

代码运行截图

![image-20240408131041131](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408131041131.png)

### 27932: Less or Equal

http://cs101.openjudge.cn/practice/27932/

思路：边界条件很重要，要注意每一层判断的顺序，不然会漏情况（因此喜提三次WA和一次Runtime Error）

代码

```python
# http://cs101.openjudge.cn/practice/27932/
n,k = map(int,input().split())
alist=sorted(list(map(int,input().split())))
if k==0:
    if alist[0]>1:
        x=1
    else:
        x=-1
elif k==n:
    x=alist[-1]
else:
    if alist[k-1]!=alist[k]:
        x=alist[k-1]
    else:
        x=-1
print(x)
```

代码运行截图 

![image-20240408133013790](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408133013790.png)

### 27948: FBI树

http://cs101.openjudge.cn/practice/27948/

思路：写完这道题刚好1h。

代码

```python
# http://cs101.openjudge.cn/practice/27948/
class TreeNode:
    def __init__(self,value):
        self.val=value
        self.left=None
        self.right=None

def build_FBI_Tree(nodes):
    if "1" in nodes and "0" in nodes:
        root=TreeNode("F")
    elif "1" not in nodes and "0" in nodes:
        root=TreeNode("B")
    else:
        root=TreeNode("I")
    if len(nodes)>1:
        root.left=build_FBI_Tree(nodes[:len(nodes)//2])
        root.right=build_FBI_Tree(nodes[len(nodes)//2:])
    return root

def postorder(root):
    result=[]
    if root:
        result.extend(postorder(root.left))
        result.extend(postorder(root.right))
        result.append(root.val)
    return result
    
N=int(input())
Snodes=list(input())
FBItree=build_FBI_Tree(Snodes)
print(*postorder(FBItree),sep="")
```

代码运行截图 

![image-20240408135334123](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408135334123.png)

### 27925: 小组队列

http://cs101.openjudge.cn/practice/27925/

思路：自己写的程序能过样例但会Runtime Error，因为没法处理先出列后小组顺序的变化，所以使用了题解中的做法，再用一个词典和deque记录每个小组的排队情况。

代码

```PYTHON
# http://cs101.openjudge.cn/practice/27925/
from collections import deque		

t = int(input())
teams = {}    #记录小组的排队情况
member_to_team = {}  #记录小组成员

for _ in range(t):
    members = list(map(int, input().split()))
    team_id = members[0] 
    teams[team_id] = deque() #用deque记录目前在队列中的小组成员
    for member in members:
        member_to_team[member] = team_id
#记录每个小组顺序的排队顺序
queue = deque() 
#set()快速寻找是否已有该小组
queue_set = set() 

while True:
    option = input().split()
    if option[0] == 'STOP':
        break
    elif option[0] == 'ENQUEUE':
        x = int(option[1])
        team = member_to_team.get(x, None) 
        #新来的小组，新开一队
        if team is None:
            team = x
            teams[team] = deque([x])
            member_to_team[x] = team
        else:
            teams[team].append(x) #插队
        if team not in queue_set: #记录小组间的排队顺序
            queue.append(team)
            queue_set.add(team)
            
    elif option[0] == 'DEQUEUE':
        if queue:
            team = queue[0]
            x = teams[team].popleft()
            print(x)
            if not teams[team]:  
                #如果当前队伍中小组没有成员排队，从现有的小组中移除
                queue.popleft()
                queue_set.remove(team)
```

代码运行截图 

![image-20240408193909230](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408193909230.png)

### 27928: 遍历树

http://cs101.openjudge.cn/practice/27928/

思路：没有弄清楚题意是什么意思，看题解发现大佬们是用字典来对应节点之间的关系，而没有建树，流程很简单。

代码

```python
# 
from collections import defaultdict
n = int(input())
tree = defaultdict(list)
parents = []
children = []
for i in range(n):
    t = list(map(int, input().split()))
    parents.append(t[0])
    if len(t) > 1:
        ch = t[1::]
        children.extend(ch)
        tree[t[0]].extend(ch)

def traversal(node):
    seq = sorted(tree[node] + [node])
    for x in seq:
        if x == node:
            print(node)
        else:
            traversal(x)

traversal((set(parents) - set(children)).pop())
```

代码运行截图 

![image-20240408212723276](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240408212723276.png)

### 2. 学习总结和收获

一小时左右AC4，从小组队列开始不行了，卡了将近一个小时，最后两题都看了题解——一部分原因是对结构掌握不熟，完不成想要的操作，令一部分是因为没有看懂题目。感觉如果上机能AC4的话还是比较满意的（希望能坚持住orz）

## Week8

Assignment #8: 图论：概念、遍历，及 树算

Updated 1919 GMT+8 Apr 8, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 19943: 图的拉普拉斯矩阵

matrices, http://cs101.openjudge.cn/practice/19943/

请定义Vertex类，Graph类，然后实现

思路：很熟悉的一道题，使用二维数组的老方法过了一遍，然后根据要求又过了一遍代码。定义的部分比较长。

代码

```python
class Vertex:	
    def __init__(self, key):
        self.id = key
        self.connectedTo = {}  #记录连接的点

    def addNeighbor(self, nbr, weight=0):
        self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + ' connectedTo: ' + str([x.id for x in self.connectedTo])

    def getConnections(self):
        return self.connectedTo.keys()

    def getId(self):
        return self.id

    def getWeight(self, nbr):
        return self.connectedTo[nbr]

class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def addVertex(self, key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex

    def getVertex(self, n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self, n):
        return n in self.vertList

    def addEdge(self, f, t, weight=0):
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], weight)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())

def constructLaplacianMatrix(n, edges):
    graph = Graph()
    for i in range(n):	# 添加顶点
        graph.addVertex(i)
    
    for edge in edges:	# 添加边
        a, b = edge
        graph.addEdge(a, b)
        graph.addEdge(b, a)
    
    laplacianMatrix = []	# 构建拉普拉斯矩阵
    for vertex in graph:
        row = [0] * n
        row[vertex.getId()] = len(vertex.getConnections())
        for neighbor in vertex.getConnections():
            row[neighbor.getId()] = -1 #除了节点以外的其他位置都是-1
        laplacianMatrix.append(row)

    return laplacianMatrix


n, m = map(int, input().split())	# 解析输入
edges = []
for i in range(m):
    a, b = map(int, input().split())
    edges.append((a, b))

laplacianMatrix = constructLaplacianMatrix(n, edges)	# 构建拉普拉斯矩阵

for row in laplacianMatrix:	# 输出结果
    print(' '.join(map(str, row)))
```

代码运行截图 

![image-20240415200418010](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415200418010.png)

### 18160: 最大连通域面积

matrix/dfs similar, http://cs101.openjudge.cn/practice/18160

思路：dfs，之前好像做过这道题，但是有点久远。需要在矩阵外边要套一层保护圈，防止越界。

代码

```python
# 
dire = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]

area = 0
def dfs(x,y):
    global area
    if matrix[x][y] == '.':return
    matrix[x][y] = '.'
    area += 1
    for i in range(len(dire)):
        dfs(x+dire[i][0], y+dire[i][1])

T=int(input())
for t in range(T):
    N,M=map(int,input().split()) 
    matrix = [['.' for _ in range(M+2)] for _ in range(N+2)]
    for i in range(1,N+1):
        matrix[i][1:-1] = input()
        
    sur = 0
    for i in range(1,N+1):
        for j in range(1,M+1):
            if matrix[i][j] == 'W':
                area = 0 
                dfs(i, j)
                sur = max(sur, area)
    print(sur)
```

代码运行截图

![image-20240415204608003](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415204608003.png)

### sy383: 最大权值连通块

https://sunnywhy.com/sfbj/10/3/383

思路：也是用dfs，并用一个列表储存节点的访问状态。

代码

```python
# 
def max_weight(n,m,weights,edges):
    graph =[[] for _ in range(n)]
    
    for edge in edges:	# 添加边
        a, b = edge
        graph[a].append(b)
        graph[b].append(a)
    
    visited = [False] * n
    max_weight = 0

    def dfs(node):
        visited[node] = True
        total_weight = weights[node]
        for neighbor in graph[node]:
            if not visited[neighbor]:
                total_weight += dfs(neighbor)
        return total_weight

    for i in range(n):
        if not visited[i]:
            max_weight = max(max_weight, dfs(i))

    return max_weight

n, m = map(int, input().split())	# 解析输入
weights=list(map(int,input().strip().split()))
edges = []
for i in range(m):
    a, b = map(int, input().split())
    edges.append((a, b))

print(max_weight(n,m,weights,edges))
```

代码运行截图

![image-20240415213156154](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415213156154.png)

### 03441: 4 Values whose Sum is 0

data structure/binary search, http://cs101.openjudge.cn/practice/03441

思路：将四个数的和为0化简为两个数的和为0，将a、b和的值与组合数储存在字典中，然后遍历c、d的和，如果-(c+d)能与a+b对应，就加上对应的组合数。

代码

```python
# 
n = int(input())
a = [0]*(n+1)
b = [0]*(n+1)
c = [0]*(n+1)
d = [0]*(n+1)

for i in range(n):
    a[i],b[i],c[i],d[i] = map(int, input().split())

dict1 = {}
for i in range(n):
    for j in range(n):
        if not a[i]+b[j] in dict1:
            dict1[a[i] + b[j]] = 0
        dict1[a[i] + b[j]] += 1

ans = 0
for i in range(n):
    for j in range(n):
        if -(c[i]+d[j]) in dict1:
            ans += dict1[-(c[i]+d[j])]

print(ans)
```

代码运行截图

![image-20240415205601574](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415205601574.png)

### 04089: 电话号码

trie, http://cs101.openjudge.cn/practice/04089/

思路：将输入的字符串按照字典序降序排列，遍历字符串列表，先调用search查找其是否存在，若存在就累加到s，然后调用insert将该字符串添加到字典树中，最后根据s的大小判断是否有冲突的电话号码。

gpt评价：利用字典树的特性,快速判断一个字符串是否已经存在于电话号码簿中。通过对字符串进行降序排列,可以保证较长的字符串先被插入到字典树中,从而能够高效地判断是否存在重复的前缀。

代码

```python
# 
class TrieNode:
    def __init__(self):
        self.child={}

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, nums):
        curnode = self.root
        for x in nums:
            if x not in curnode.child:
                curnode.child[x] = TrieNode()
            curnode=curnode.child[x]

    def search(self, num):
        curnode = self.root
        for x in num:
            if x not in curnode.child:
                return 0
            curnode = curnode.child[x]
        return 1


t=int(input())

for _ in range(t):
    n=int(input())
    nums=[str(input()) for __ in range(n)]
    nums.sort()
    nums.reverse()
    
    s = 0
    trie = Trie()
    for num in nums:
        s += trie.search(num)
        trie.insert(num)
    if s > 0:
        print('NO')
    else:
        print('YES')
```

代码运行截图 

![image-20240415210833288](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415210833288.png)

### 04082: 树的镜面映射

http://cs101.openjudge.cn/practice/04082/

思路：题目看得一知半解，于是去看了题解，还是看得一知半解orz

代码

```python
# 
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.x = x
        self.children = []

def create_node():
    return TreeNode('')

def build_tree(tempList, index):
    node = create_node()
    node.x = tempList[index][0]
    if tempList[index][1] == '0':
        index += 1
        child, index = build_tree(tempList, index)
        node.children.append(child)
        index += 1
        child, index = build_tree(tempList, index)
        node.children.append(child)
    return node, index

def print_tree(p):
    Q = deque()
    s = deque()

    # 遍历右子节点并将非虚节点加入栈s
    while p is not None:
        if p.x != '$':
            s.append(p)
        p = p.children[1] if len(p.children) > 1 else None

    # 将栈s中的节点逆序放入队列Q
    while s:
        Q.append(s.pop())

    # 宽度优先遍历队列Q并打印节点值
    while Q:
        p = Q.popleft()
        print(p.x, end=' ')

        # 如果节点有左子节点，将左子节点及其右子节点加入栈s
        if p.children:
            p = p.children[0]
            while p is not None:
                if p.x != '$':
                    s.append(p)
                p = p.children[1] if len(p.children) > 1 else None

            # 将栈s中的节点逆序放入队列Q
            while s:
                Q.append(s.pop())


n = int(input())
tempList = input().split()

# 构建多叉树
root, _ = build_tree(tempList, 0)

# 执行宽度优先遍历并打印镜像映射序列
print_tree(root)
```

代码运行截图 

![image-20240415220056432](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240415220056432.png)

### 2. 学习总结和收获

本周刚好在做另一门课的大作业，所以没有额外的时间给数算，周一花了一下午+一晚上的时间写完了作业，过程一头雾水。一边问gpt老师一边做题理解，希望后面几周能多做几道题（对自己现在的做题状况表示担忧orz

## Week9

Assignment #9: 图论：遍历，及 树算



Updated 1739 GMT+8 Apr 14, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 04081: 树的转换

http://cs101.openjudge.cn/dsapre/04081/

思路：需要同时记录两种树型的信息

代码

```python
# 
class TreeNode:
    def __init__(self):
        self.children=[]
        self.leftson=None
        self.rightson=None

def buildtree(treestr):
    root=TreeNode()
    stack=[root]
    depth=0
    for _ in treestr:
        node=stack[-1]
        if _ =="d":
            newnode=TreeNode()
            if not node.children:
                node.leftson=newnode
            else:
                node.children[-1].rightson=newnode
            node.children.append(newnode)
            stack.append(newnode)
            depth=max(depth,len(stack)-1)
        else:
            stack.pop()             
    return root,depth
    
def depth_changed(node):
    if not node:
        return -1
    return max(depth_changed(node.leftson),depth_changed(node.rightson))+1
 
   
treestr=str(input())
root,h1=buildtree(treestr)
h2=depth_changed(root)
print(h1,"=>",h2,sep=" ")
```

代码运行截图

![image-20240421222440412](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240421222440412.png)

### 08581: 扩展二叉树

http://cs101.openjudge.cn/dsapre/08581/

思路：得到的序列就是前序遍历，所以用中、左、右的顺序递归位次，遇到“.”就在该节点返回None

代码

```python
# 
class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

def buildtree(treelist):
    if not treelist:
        return None
    
    value=treelist.pop(0)
    if value==".":
        return None
    
    root=TreeNode(value)
    root.left=buildtree(treelist)
    root.right=buildtree(treelist)
    
    return root

    
def inorder(node):
    if not node:
        return []
    left=inorder(node.left)
    right=inorder(node.right)
    return left+[node.value]+right

def postorder(node):
    if not node:
        return []
    left=postorder(node.left)
    right=postorder(node.right)
    return left+right+[node.value]

    
treelist=list(input())
tree=buildtree(treelist)
print(*inorder(tree),sep="")
print(*postorder(tree),sep="")
```

代码运行截图

![image-20240421225059672](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240421225059672.png)

### 22067: 快速堆猪

http://cs101.openjudge.cn/practice/22067/

思路：除了储存猪顺序的列表外，还需要一个储存每个猪之前的最轻的猪的列表，不然会超时

代码

```python
# 
pigs_stacked=[]
lightest=[]

while True:
    try:
        operation=input().split()
        ope=operation[0]
        if not pigs_stacked:
            if ope=="push":
                pigs_stacked.append(int(operation[1]))
                lightest.append(pigs_stacked[-1])
            else:
                continue
        else:
            if ope=="pop":
               pigs_stacked.pop()
               if lightest:
                   lightest.pop()
               
            elif ope=="min":
                print(lightest[-1])
                
            else:
                pigs_stacked.append(int(operation[1]))
                lightest.append(min(pigs_stacked[-1],lightest[-1]))
           
    except EOFError:
        break
```

代码运行截图

![image-20240422205859109](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240422205859109.png)

### 04123: 马走日

dfs, http://cs101.openjudge.cn/practice/04123

思路：dfs不是很熟练

代码

```python
#
maxn=10
sx=[-2,-1,1,2,2,1,-1,-2]
sy=[1,2,2,1,-1,-2,-2,-1]

ans=0

def dfs(dep:int,x,y):
    if n*m==dep:
        global ans
        ans+=1
        return
    
    for _ in range(8):
        u=x+sx[_]
        v=y+sy[_]
        if chess[u][v]==False and 0 <= u < n and 0 <= v < m:
            chess[u][v]=True
            dfs(dep+1,u,v)
            chess[u][v]=False


T=int(input())
for t in range(T):
    n,m,x,y=map(int,input().split())
    chess=[[False]*maxn for _ in range(maxn)]
    ans=0
    chess[x][y]=True
    dfs(1,x,y)
    print(ans)
```

代码运行截图

![image-20240422215325761](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240422215325761.png)

### 28046: 词梯

bfs, http://cs101.openjudge.cn/practice/28046/

思路：

代码

```python
# 
import sys
from collections import deque

class Graph:
    def __init__(self):
        self.vertices = {}
        self.num_vertices = 0

    def add_vertex(self, key):
        self.num_vertices = self.num_vertices + 1
        new_vertex = Vertex(key)
        self.vertices[key] = new_vertex
        return new_vertex

    def get_vertex(self, n):
        if n in self.vertices:
            return self.vertices[n]
        else:
            return None

    def __len__(self):
        return self.num_vertices

    def __contains__(self, n):
        return n in self.vertices

    def add_edge(self, f, t, cost=0):
        if f not in self.vertices:
            nv = self.add_vertex(f)
        if t not in self.vertices:
            nv = self.add_vertex(t)
        self.vertices[f].add_neighbor(self.vertices[t], cost)

    def get_vertices(self):
        return list(self.vertices.keys())

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, num):
        self.key = num
        self.connectedTo = {}
        self.color = 'white'
        self.distance = sys.maxsize
        self.previous = None
        self.disc = 0
        self.fin = 0

    def add_neighbor(self, nbr, weight=0):
        self.connectedTo[nbr] = weight

    # def setDiscovery(self, dtime):
    #     self.disc = dtime
    #
    # def setFinish(self, ftime):
    #     self.fin = ftime
    #
    # def getFinish(self):
    #     return self.fin
    #
    # def getDiscovery(self):
    #     return self.disc

    def get_neighbors(self):
        return self.connectedTo.keys()

    # def getWeight(self, nbr):
    #     return self.connectedTo[nbr]

    # def __str__(self):
    #     return str(self.key) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(
    #         self.fin) + ":dist " + str(self.distance) + ":pred \n\t[" + str(self.previous) + "]\n"



def build_graph(all_words):
    buckets = {}
    the_graph = Graph()
    
    # 创建词桶 create buckets of words that differ by 1 letter
    for line in all_words:
        word = line.strip()
        for i, _ in enumerate(word): #enumerate两个返回值，用_占位
            bucket = f"{word[:i]}_{word[i + 1:]}" 
            buckets.setdefault(bucket, set()).add(word) #防止没有的key报错
    # 为同一个桶中的单词添加顶点和边
    for similar_words in buckets.values():
        for word1 in similar_words:
            for word2 in similar_words - {word1}:
                the_graph.add_edge(word1, word2)
    return the_graph

def bfs(start, end):
    start.distnce = 0
    start.previous = None
    vert_queue = deque()
    vert_queue.append(start)
    while len(vert_queue) > 0:
        current = vert_queue.popleft()  # 取队首作为当前顶点
        if current == end:
            return True
        for neighbor in current.get_neighbors():  # 遍历当前顶点的邻接顶点
            if neighbor.color == "white":
                neighbor.color = "gray"
                neighbor.distance = current.distance + 1
                neighbor.previous = current
                vert_queue.append(neighbor)
        current.color = "black"  # 当前顶点已经处理完毕，设黑色
        
    return False

"""
BFS 算法主体是两个循环的嵌套: while-for
    while 循环对图中每个顶点访问一次，所以是 O(|V|)；
    嵌套在 while 中的 for，由于每条边只有在其起始顶点u出队的时候才会被检查一次，
    而每个顶点最多出队1次，所以边最多被检查次，一共是 O(|E|)；
    综合起来 BFS 的时间复杂度为 0(V+|E|)

词梯问题还包括两个部分算法
    建立 BFS 树之后，回溯顶点到起始顶点的过程，最多为 O(|V|)
    创建单词关系图也需要时间，时间是 O(|V|+|E|) 的，因为每个顶点和边都只被处理一次
"""

def traverse(starting_vertex): #沿着previous找到之前的vertex
    ans = []
    current = starting_vertex
    while (current.previous):
        ans.append(current.key)
        current = current.previous
    ans.append(current.key)
    return ans


n = int(input())
all_words = []
for _ in range(n):
    all_words.append(input().strip())
g = build_graph(all_words)
s, e = input().split()
start, end = g.get_vertex(s), g.get_vertex(e)

if start is None or end is None:
    print('NO')
    exit(0)
if bfs(start, end):
    ans = traverse(end)
    print(' '.join(ans[::-1]))
else:
    print('NO')
    
    
#不用graph和vertex的方法，费时间
from collections import defaultdict
dic=defaultdict(list)
n,lis=int(input()),[]
for i in range(n):
    lis.append(input())
for word in lis:
    for i in range(len(word)):
        bucket=word[:i]+'_'+word[i+1:]
        dic[bucket].append(word) #创建字典，让每组三个字母一样的词关联在一起
def bfs(start,end,dic):
    queue=[(start,[start])]
    visited=[start]
    while queue:
        currentword,currentpath=queue.pop(0)
        if currentword==end:
            return ' '.join(currentpath)
        for i in range(len(currentword)):
            bucket=currentword[:i]+'_'+currentword[i+1:]
            for nbr in dic[bucket]:
                if nbr not in visited:
                    visited.append(nbr)
                    newpath=currentpath+[nbr]
                    queue.append((nbr,newpath))
    return 'NO'
start,end=map(str,input().split())    
print(bfs(start,end,dic))
```

代码运行截图 

![image-20240422224836580](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240422224836580.png)

### 28050: 骑士周游

dfs, http://cs101.openjudge.cn/practice/28050/

思路：

代码

```python
# 
import sys

class Graph:
    def __init__(self):
        self.vertices = {}
        self.num_vertices = 0

    def add_vertex(self, key):
        self.num_vertices = self.num_vertices + 1
        new_ertex = Vertex(key)
        self.vertices[key] = new_ertex
        return new_ertex

    def get_vertex(self, n):
        if n in self.vertices:
            return self.vertices[n]
        else:
            return None

    def __len__(self):
        return self.num_vertices

    def __contains__(self, n):
        return n in self.vertices

    def add_edge(self, f, t, cost=0):
        if f not in self.vertices:
            nv = self.add_vertex(f)
        if t not in self.vertices:
            nv = self.add_vertex(t)
        self.vertices[f].add_neighbor(self.vertices[t], cost)
        #self.vertices[t].add_neighbor(self.vertices[f], cost)

    def getVertices(self):
        return list(self.vertices.keys())

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, num):
        self.key = num
        self.connectedTo = {}
        self.color = 'white'
        self.distance = sys.maxsize
        self.previous = None
        self.disc = 0
        self.fin = 0

    def __lt__(self,o):
        return self.key < o.key

    def add_neighbor(self, nbr, weight=0):
        self.connectedTo[nbr] = weight


    # def setDiscovery(self, dtime):
    #     self.disc = dtime
    #
    # def setFinish(self, ftime):
    #     self.fin = ftime
    #
    # def getFinish(self):
    #     return self.fin
    #
    # def getDiscovery(self):
    #     return self.disc

    def get_neighbors(self):
        return self.connectedTo.keys()

    # def getWeight(self, nbr):
    #     return self.connectedTo[nbr]

    def __str__(self):
        return str(self.key) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(
            self.fin) + ":dist " + str(self.distance) + ":pred \n\t[" + str(self.previous) + "]\n"



def knight_graph(board_size):
    kt_graph = Graph()
    for row in range(board_size):           #遍历每一行
        for col in range(board_size):       #遍历行上的每一个格子
            node_id = pos_to_node_id(row, col, board_size) #把行、列号转为格子ID
            new_positions = gen_legal_moves(row, col, board_size) #按照 马走日，返回下一步可能位置
            for row2, col2 in new_positions:
                other_node_id = pos_to_node_id(row2, col2, board_size) #下一步的格子ID
                kt_graph.add_edge(node_id, other_node_id) #在骑士周游图中为两个格子加一条边
    return kt_graph

def pos_to_node_id(x, y, bdSize):
    return x * bdSize + y
def NodeToPos(id):
    return ((id//8, id%8))
def gen_legal_moves(row, col, board_size):
    new_moves = []
    move_offsets=[(-1,-2),(-1,2),(-2,-1),(-2,1),
                  (1,-2),(1,2),(2,-1),(2,1)]
    for r_off, c_off in move_offsets:
        if (                                # #检查，不能走出棋盘
            0 <= row + r_off < board_size
            and 0 <= col + c_off < board_size
        ):
            new_moves.append((row + r_off, col + c_off))
    return new_moves

# def legal_coord(row, col, board_size):
#     return 0 <= row < board_size and 0 <= col < board_size


def knight_tour(n, path, u, limit):
    u.color = "gray"
    path.append(u)              #当前顶点涂色并加入路径
    if n < limit:
        neighbors = ordered_by_avail(u) #对所有的合法移动依次深入
        #neighbors = sorted(list(u.get_neighbors()))
        i = 0

        for nbr in neighbors:
            if nbr.color == "white" and \
                knight_tour(n + 1, path, nbr, limit):   #选择“白色”未经深入的点，层次加一，递归深入
                return True
        else:                       #所有的“下一步”都试了走不通
            path.pop()              #回溯，从路径中删除当前顶点
            u.color = "white"       #当前顶点改回白色
            return False
    else:
        return True

def ordered_by_avail(n):
    res_list = []
    for v in n.get_neighbors():
        if v.color == "white":
            c = 0
            for w in v.get_neighbors():
                if w.color == "white":
                    c += 1
            res_list.append((c,v))
    res_list.sort(key = lambda x: x[0])
    return [y[1] for y in res_list]

# class DFSGraph(Graph):
#     def __init__(self):
#         super().__init__()
#         self.time = 0                   #不是物理世界，而是算法执行步数
# 
#     def dfs(self):
#         for vertex in self:
#             vertex.color = "white"      #颜色初始化
#             vertex.previous = -1
#         for vertex in self:             #从每个顶点开始遍历
#             if vertex.color == "white":
#                 self.dfs_visit(vertex)  #第一次运行后还有未包括的顶点
#                                         # 则建立森林
# 
#     def dfs_visit(self, start_vertex):
#         start_vertex.color = "gray"
#         self.time = self.time + 1       #记录算法的步骤
#         start_vertex.discovery_time = self.time
#         for next_vertex in start_vertex.get_neighbors():
#             if next_vertex.color == "white":
#                 next_vertex.previous = start_vertex
#                 self.dfs_visit(next_vertex)     #深度优先递归访问
#         start_vertex.color = "black"
#         self.time = self.time + 1
#         start_vertex.closing_time = self.time


bdSize = int(input())  # 棋盘大小
*start_pos, = map(int, input().split())  # 起始位置
g = knight_graph(bdSize)
start_vertex = g.get_vertex(pos_to_node_id(start_pos[0], start_pos[1], bdSize))
if start_vertex is None:
    print("fail")

tour_path = []
done = knight_tour(0, tour_path, start_vertex, bdSize * bdSize-1)
if done:
    print("success")
else:
    print("fail")

# 打印路径
cnt = 0
for vertex in tour_path:
    cnt += 1
    if cnt % bdSize == 0:
        print()
    else:
        print(vertex.key, end=" ")
```

代码运行截图 

![image-20240423114531007](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240423114531007.png)

### 2. 学习总结和收获

感觉在上强度了，最大的感受是单独出来Graph和Vertex是什么结构，但是放在题目中就不知道怎么用了，题解都能看懂意思，但是自己写肯定不会有这样清晰的思路。希望接下来的五一假期能有时间多练几道题，必须得逼自己多做题才行orz

## week10

Assignment #A: 图论：算法，树算及栈

Updated 2018 GMT+8 Apr 21, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 20743: 整人的提词本

http://cs101.openjudge.cn/practice/20743/

思路：利用栈互相转换。遇到）就将上一个（之前的字符串全部弹出，借助另一个空列表反序后重新压入，依次类推。

代码

```python
# 
s1=list(input())
stack=[]
tmp=[]
for s in s1:
    stack.append(s)
    if stack[-1]==")":
        stack.pop()
        while stack[-1]!="(":
            tmp.append(stack.pop())
        stack.pop()
                
        while tmp:
            stack.append(tmp.pop(0))
print(*stack,sep="")
```

代码运行截图 

![image-20240430111644504](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430111644504.png)

### 02255: 重建二叉树

http://cs101.openjudge.cn/practice/02255/

思路：即已知前中序，建树并输出后序遍历

代码

```python
# 

class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

def buildTree(preorder,inorder):
    if not preorder or not inorder:
        return None
    root_value=preorder.pop(0)
    root=TreeNode(root_value)
    
    root_index=inorder.index(root_value)
    
    root.left=buildTree(preorder, inorder[:root_index])
    root.right=buildTree(preorder, inorder[root_index+1:])
    
    return root

def postorder(root):
    result=[]
    if root:
        result.extend(postorder(root.left))
        result.extend(postorder(root.right))
        result.extend(root.value)
    return result
    
while True:
    try:
        preorder,inorder=map(str,input().split())
        root=buildTree(list(preorder), list(inorder)) 
        print(*postorder(root),sep="")
    except EOFError:
        break  
```

代码运行截图

![image-20240430113126895](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430113126895.png)

### 01426: Find The Multiple

http://cs101.openjudge.cn/practice/01426/

思路：

代码

```python
# 
from collections import deque

def find_multiple(n):
    q = deque()
    # 初始化队列，存储的是(模n值, 对应的数字字符串)
    q.append((1 % n, "1"))
    visited = set([1 % n])  # 用于记录访问过的模n值，避免重复搜索

    while q:
        mod, num_str = q.popleft()
        # 检查当前模n值是否为0，是则找到答案
        if mod == 0:
            return num_str
        # 尝试在当前数字后加0或加1，生成新的数字，并计算模n值
        for digit in ["0", "1"]:
            new_num_str = num_str + digit
            new_mod=int(new_num_str)%n
            # 如果新模n值未访问过，则加入队列继续搜索
            if new_mod not in visited:
                q.append((new_mod, new_num_str))
                visited.add(new_mod)

while True:
    n=int(input())  
    if n==0:
        break
    print(find_multiple(n))
```

代码运行截图

![image-20240430120611434](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430120611434.png)

### 04115: 鸣人和佐助

bfs, http://cs101.openjudge.cn/practice/04115/

思路：需要记录每个走过的格子时剩余的查克拉和花费的时间，对bfs的感受加深了一些

代码

```python
# 
from collections import deque

direc=[(0,1),(1,0),(0,-1),(-1,0)]
start,end=None,None

M,N,T=map(int,input().split())
Map=[list(input()) for i in range(M)]

for i in range(M):
    for j in range(N):
        if Map[i][j]=="@":
            start=(i,j)

def bfs():
    q=deque([start +(T,0)])
    visited=[[-1]*N for i in range(M)] #用来记录每个点的访问状态与剩余查克拉
    visited[start[0]][start[1]]=T
    while q:
        x,y,t,time=q.popleft()
        time+=1
        for dx,dy in direc:
            if 0<=x+dx<M and 0<=y+dy<N: #不能出地图
                if  (elem:=Map[x+dx][y+dy])=="*" and t>visited[x+dx][y+dy]: #路上没有大蛇丸手下
                    visited[x+dx][y+dy]=t
                    q.append((x+dx,y+dy,t,time))
                elif elem=="#" and t>0 and t-1>visited[x+dx][y+dy]:
                    #路上有大蛇丸手下，如果有富余查克拉可以走
                    visited[x+dx][y+dy] =t-1
                    q.append((x+dx,y+dy,t-1,time))
                elif elem =="+":
                    return time
    return -1
print(bfs())
```

代码运行截图

![image-20240430160727928](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430160727928.png)

### 20106: 走山路

Dijkstra, http://cs101.openjudge.cn/practice/20106/

思路：bfs找到了一点感觉，但是这道题还是没写出来，观摩了大佬们的题解

代码

```python
# 

from heapq import heappop, heappush

def bfs(sx, sy):
    q = [(0, sx, sy)]
    visited = set()
    while q:
        ans, x, y = heappop(q)
        if (x, y) in visited:	# 剪枝
            continue
        visited.add((x, y))
        if x == ex and y == ey:
            return ans
        for dx, dy in direc:
            nx, ny = x+dx, y+dy
            if 0 <= nx < m and 0 <= ny < n and \
                    Map[nx][ny] != '#' and (nx, ny) not in visited:
                new_ans = ans+abs(int(Map[nx][ny])-int(Map[x][y]))
                heappush(q, (new_ans, nx, ny))
    return 'NO'


m, n, p = map(int, input().split())
Map = [list(input().split()) for _ in range(m)]
direc= [(1, 0), (-1, 0), (0, 1), (0, -1)]
for _ in range(p):
    sx, sy, ex, ey = map(int, input().split())
    if Map[sx][sy] == '#' or Map[ex][ey] == '#':
        print('NO')
        continue
    print(bfs(sx,sy))
```

代码运行截图

![image-20240430173050491](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430173050491.png)

### 05442: 兔子与星空

Prim, http://cs101.openjudge.cn/practice/05442/

思路：发现题解大佬并没有搓Graph，Prim类型的题第一次见

代码

```python
# 
import heapq

def prim(graph, start):
    mst = []
    used = set([start])
    edges = [(cost, start, to)
        for to, cost in graph[start].items()
    ]
    heapq.heapify(edges)

    while edges:
        cost, frm, to = heapq.heappop(edges)
        if to not in used:
            used.add(to)
            mst.append((frm, to, cost))
            for to_next, cost2 in graph[to].items():
                if to_next not in used:
                    heapq.heappush(edges, (cost2, to, to_next))

    return mst

def solve():
    n = int(input())
    graph = {chr(i+65): {} for i in range(n)}
    for i in range(n-1):
        data = input().split()
        star = data[0]
        m = int(data[1])
        for j in range(m):
            to_star = data[2+j*2]
            cost = int(data[3+j*2])
            graph[star][to_star] = cost
            graph[to_star][star] = cost
    mst = prim(graph, 'A')
    print(sum(x[2] for x in mst))
```

代码运行截图

![image-20240430173412365](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430173412365.png)

### 2. 学习总结和收获

原本以为五一会有时间多做些题，结果出去玩放飞了，差点错过今天的ddl，orz

## week11

Assignment #B: 图论和树算

Updated 1709 GMT+8 Apr 28, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 28170: 算鹰

dfs, http://cs101.openjudge.cn/practice/28170/

思路：dfs和bfs一直不是很擅长，没有找到题解有点迷茫，一开始搞错了题意，以为是将十字形状的己方棋子称为一只鹰，后来发现是把连成一片叫一只鹰（orz）。思路是找到棋盘中有多少上下左右四个方向连成一片的己方棋子，使用一个二维数组记录每个点的访问状况。

代码

```python
# 
def dfs(grid, visited, i, j):
    # 检查坐标是否越界，当该位置已访问或不是己方棋子时返回
    if not 0<=i<10 or not 0<=j<10 or visited[i][j] or grid[i][j] != '.':
        return    
    visited[i][j] = True #将现在的己方棋子改为已访问状态
    #遍历所有相连的己方棋子并标记为已访问
    dfs(grid, visited, i-1, j)  # 上方
    dfs(grid, visited, i+1, j)  # 下方
    dfs(grid, visited, i, j-1)  # 左方
    dfs(grid, visited, i, j+1)  # 右方

def countEagles(grid):
    count = 0
    visited = [[False]*10 for _ in range(10)]
    for i in range(10):
        for j in range(10):
            if not visited[i][j] and grid[i][j] == '.':                
                dfs(grid, visited, i, j) #每次调用dfs说明发现了一只新的“鹰”
                count+=1 
    return count
Map=[list(input()) for i in range(10)]
print(countEagles(Map))
```

代码运行截图 

![image-20240430201024196](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430201024196.png)

### 02754: 八皇后

dfs, http://cs101.openjudge.cn/practice/02754/

思路：先根据回溯将所有八皇后解法算出来，由于回溯时是按照大小顺序来的，所以储存在列表中的解法的位置就与“b-1”相对应（即，第2个解法被存在了solutions的1号位）。经典题，很早之前就见大佬们轮番挑战了，但是自己实在是菜orz，学习大佬题解，膜。

代码

```python
# 
def solve_n_queens(n):
    solutions = []  # 存储所有解决方案的列表
    queens = [-1] * n  # 存储每一行皇后所在的列数
    
    def backtrack(row):
        if row == n:  # 找到一个合法解决方案
            solutions.append(queens.copy())
        else:
            for col in range(n):
                if is_valid(row, col):  # 检查当前位置是否合法
                    queens[row] = col  # 在当前行放置皇后
                    backtrack(row + 1)  # 递归处理下一行
                    queens[row] = -1  # 回溯，撤销当前行的选择
    
    def is_valid(row, col):
        for r in range(row):
            if queens[r] == col or abs(row - r) == abs(col - queens[r]):
                return False
        return True  
    
    backtrack(0)  # 从第一行开始回溯
    return solutions

# 获取第 b 个皇后串
def get_queen_string(b):
    solutions = solve_n_queens(8)
    if b > len(solutions):
        return None
    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string

n=int(input())
for ns in range(n):
    b=int(input())
    print(get_queen_string(b))
```

代码运行截图

![image-20240430204652524](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430204652524.png)

### 03151: Pots

bfs, http://cs101.openjudge.cn/practice/03151/

思路：总之就是要记录每一种操作后，两个罐子里的水，并将所有操作用一个分隔符记录下来，最后用split分开分隔符按行输出。由于每种操作之后对应的状态都不一样，所以中间比较繁琐。（看群里的讨论，代码应该还能化简，但是犯懒了orz）

代码

```python
# 
from collections import deque

def bfs(A, B, C):
    visited = set()
    q=deque([(0, 0, "")])#两个罐子的初始水量，第三位用于记录操作

    while q:
        x, y, operations = q.popleft()
        if x == C or y == C: #符合题意的罐子水量
            return operations

        all_operations = [
            ("FILL", 1, y, "FILL(1)"),("FILL", 2, x, "FILL(2)"),
            ("DROP", 1, 0, "DROP(1)"),("DROP", 2, 0, "DROP(2)"),
            ("POUR", 1, 2, "POUR(1,2)"),("POUR", 2, 1, "POUR(2,1)")
        ]
        #分别对应：操作，罐子编号，该罐子操作后的水量，记录操作
        for action, i, j, operation in all_operations:
            if action == "FILL":   #装满
                if i == 1:
                    #操作后，1号罐子最大水量，2号罐子水量不变，记录操作
                    new_state = (A, y, operation)
                else:
                    #同理，2号罐最大水量
                    new_state = (x, B, operation)
            elif action == "DROP":   #清空
                if i == 1:
                    new_state = (0, y, operation)
                else:
                    new_state = (x, 0, operation)
            else: #倾倒
                if i == 1:   #从1号倒入2号
                    if x + y <= B: 
                        new_state = (0, x + y, operation)
                    else:
                        new_state = (x + y - B, B, operation)
                else:
                    if x + y <= A:
                        new_state = (x + y, 0, operation)
                    else:
                        new_state = (A, x + y - A, operation)

            if new_state not in visited:
                visited.add(new_state)
                q.append((new_state[0], new_state[1], operations + operation + "\n"))

    return "impossible"

A, B, C = map(int, input().split())

result = bfs(A, B, C)
if result == "impossible":
    print(result)
else:
    result = result.strip().split("\n")
    print(len(result))
    for step in result:
        print(step)
```

代码运行截图

![image-20240430212556388](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430212556388.png)

### 05907: 二叉树的操作

http://cs101.openjudge.cn/practice/05907/

思路：先按照规定建树，将所有节点对应的子树也都储存起来，方便后续交换

代码

```python
# 
class TreeNode:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None
        
def buildTree(nodes):
    root=[TreeNode(i) for i in range(n)] #给所有的节点建子树
    for value,left,right in nodes: #将子树汇集到root[0]
        if left!=-1:
            root[value].left=root[left]
        if right!=-1:
            root[value].right=root[right]        
    return root #包含所有子树信息

def exchangesons(nodes,node1,node2):
    for node in nodes:
        if node.left and node.left.value in [node1,node2]:
            node.left=nodes[node2] if node.left.value==node1 else nodes[node1]
        if node.right and node.right.value in [node1,node2]:
            node.right=nodes[node2] if node.right.value==node1 else nodes[node1]
    
def farthest_to_the_left(node):
    while node and node.left: #该节点存在左子节点
        node=node.left #到下一层继续检索
    return node.value if node else -1 #返回最后一个左节点（实际上不会返回-1）
    
t=int(input())
for ts in range(t):
    n,m=map(int,input().split())
    nodes=[]
    for ns in range(n):
        X,Y,Z=map(int,input().split())
        nodes.append((X,Y,Z))
        
    tree=buildTree(nodes)
    
    for ms in range(m):
        operation=list(map(int,input().split()))
        if operation[0]==1:
            exchangesons(tree,operation[1],operation[2])
            
        elif operation[0]==2:
            print(farthest_to_the_left(tree[operation[1]]))
```

代码运行截图

![image-20240430221022810](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240430221022810.png)

### 18250: 冰阔落 I

Disjoint set, http://cs101.openjudge.cn/practice/18250/

思路：使用列表储存每一杯阔落的去向

代码

```python
# 
def find(x):
    if parent[x]!= x:
        parent[x] = find(parent[x])
    return parent[x]
def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_y] = root_x                
while True:
    try:
        n,m=map(int,input().split())
        parent=list(range(n+1))
        
        for ms in range(m):
            x,y=map(int,input().split())
            if find(x)==find(y):
                print("Yes")
            else:
                print("No")
                union(x,y)
        unique_parents=set(find(x) for x in range(1,n+1))
        cola_cup=sorted(unique_parents)        
        print(len(cola_cup))
        print(*cola_cup)         
    except EOFError:
        break
```

代码运行截图

![image-20240505180916917](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240505180916917.png)

### 05443: 兔子与樱花

http://cs101.openjudge.cn/practice/05443/

思路：原来将距离的初始值设为无限大也是可以的，从题解中学习到了很多

代码

```python
#
import heapq

def dijkstra(adjacency, start):
    distances = {vertex: float('infinity') for vertex in adjacency}
    previous = {vertex: None for vertex in adjacency}
    distances[start] = 0
    pq = [(0, start)]

    while pq:
        current_distance, current_vertex = heapq.heappop(pq)
        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in adjacency[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))

    return distances, previous

def shortest_path_to(adjacency, start, end):
    distances, previous = dijkstra(adjacency, start)
    path = []
    current = end
    while previous[current] is not None:
        path.insert(0, current)
        current = previous[current]
    path.insert(0, start)
    return path, distances[end]

P = int(input())
places = {input().strip() for _ in range(P)}

Q = int(input())
graph = {place: {} for place in places}
for _ in range(Q):
    x, y, dist = input().split()
    dist = int(dist)
    graph[x][y] = dist
    graph[y][x] = dist 

R = int(input())
for Rs in range(R):   
    start,end = input().split()
    if start==end:
        print(start)
        continue
    
    path, total_dist = shortest_path_to(graph, start, end)
    output = ""
    for i in range(len(path) - 1):
        output += f"{path[i]}->({graph[path[i]][path[i+1]]})->"
    output += f"{end}"
    print(output)
```

代码运行截图 

![image-20240505190741817](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240505190741817.png)

### 2. 学习总结和收获

由于五一出游，每天走路排队已经消耗完力气，完全没有按计划学习。明天一天都要花在返校路上，高铁信号和电脑电量不敢保证（主要是网络问题），所以今天必须腾出时间写作业。如果不是上周写assignmentA手感好，多写了点B的内容，今天不知道要写多久。（一想到今晚还有很多个ddl，简直头大……）

## week13

Assignment #D: May月考

Updated 1654 GMT+8 May 8, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 02808: 校门外的树

http://cs101.openjudge.cn/practice/02808/

思路：用一个列表储存树的状态，有就是1，没有就是0

代码

```python
# 
L,M=map(int,input().split())
trees=[1]*(L+1)
for m in range(M):
    start,ending =map(int,input().split())
    for _ in range(start,ending+1):
        trees[_]=0
print(sum(trees))
```

代码运行截图

![image-20240517170034508](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240517170034508.png)

### 20449: 是否被5整除

http://cs101.openjudge.cn/practice/20449/

思路：需要注意每次往右一位之后的新二进制数都是从右往左看2的几次方，不然就容易错。每次往右扩充一位相当于原来的二进制数×2（余数也×2）后再加上最右位，所以只需要记录每次的余数就可以了

代码

```python
# 
inp=list(input())
out=""
ans=0
for i in range(len(inp)):
    ans=(ans*2+int(inp[i]))%5
    if ans==0:
        out+="1"
    else:
        out+="0"
print(out)
```

代码运行截图

![image-20240517173718366](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240517173718366.png)

### 01258: Agri-Net

http://cs101.openjudge.cn/practice/01258/

思路：Prim（最小生成树算法）

代码

```python
# 
from heapq import heappop, heappush


while True:
    try:
        n = int(input())
    except:
        break
    mat, cur = [], 0
    for i in range(n):
        mat.append(list(map(int, input().split())))
    d, v, q, cnt = [100000 for i in range(n)], set(), [], 0
    d[0] = 0
    heappush(q, (d[0], 0))
    while q:
        x, y = heappop(q)
        if y in v:
            continue
        v.add(y)
        cnt += d[y]
        for i in range(n):
            if d[i] > mat[y][i]:
                d[i] = mat[y][i]
                heappush(q, (d[i], i))
    print(cnt)
```

代码运行截图 

![image-20240517202845339](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240517202845339.png)

### 27635: 判断无向图是否连通有无回路(同23163)

http://cs101.openjudge.cn/practice/27635/

思路：先将每个点的连通关系存储起来，然后对每个点进行dfs，记录已经访问的点，当存在一个已经被访问过的非父节点的邻点时，说明存在循环。最后判断，如果访问过的点数等于总点数，说明这一条通路连通。

代码

```python
# 
n,m=map(int,input().split())
edge=[[] for _ in range(n)]
for _ in range(m): #存储联通关系
    u,v=map(int,input().split())
    edge[u].append(v)
    edge[v].append(u)
cnt,flag=set(),False

def dfs(x,y): #x为当前点，y为父节点
    global cnt,flag
    cnt.add(x)
    for i in edge[x]: #遍历当前节点的邻居
        if i not in cnt: #对还没访问过的邻点继续dfs
            dfs(i,x)
        elif y !=i: #邻点已经被访问过，且不是父节点
            flag=True
            
for i in range(n): #对每个点进行dfs
    cnt.clear() #清空之前访问的set
    dfs(i,-1)
    if len(cnt)==n: #联通的
        break
    if flag: #循环的
        break
    
print("connected:"+("yes" if len(cnt)==n else "no"))
print("loop:"+("yes" if flag else "no"))
```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

### 27947: 动态中位数

http://cs101.openjudge.cn/practice/27947/

思路：没想到开两个堆，人反应慢了……豁然开朗

代码

```python
# 
import heapq

def dynamic_median(nums):
    # 维护小根和大根堆（对顶），保持中位数在大根堆的顶部
    min_heap = []  # 存储较大的一半元素，使用最小堆
    max_heap = []  # 存储较小的一半元素，使用最大堆

    median = []
    for i, num in enumerate(nums):
        # 根据当前元素的大小将其插入到对应的堆中
        if not max_heap or num <= -max_heap[0]:
            heapq.heappush(max_heap, -num)
        else:
            heapq.heappush(min_heap, num)

        # 调整两个堆的大小差，使其不超过 1
        if len(max_heap) - len(min_heap) > 1:
            heapq.heappush(min_heap, -heapq.heappop(max_heap))
        elif len(min_heap) > len(max_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))

        if i % 2 == 0:
            median.append(-max_heap[0])

    return median

T = int(input())
for _ in range(T):
    #M = int(input())
    nums = list(map(int, input().split()))
    median = dynamic_median(nums)
    print(len(median))
    print(*median)
```

代码运行截图 

![image-20240517205120549](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240517205120549.png)

### 28190: 奶牛排队

http://cs101.openjudge.cn/practice/28190/

思路：向题解投降……考试的时候可能看到这种直接跳过了orz

代码

```python
# 
N = int(input())
cows = [int(input()) for _ in range(N)]

left_bound = [-1] * N
right_bound = [N] * N

stack = []  # 单调栈，存储索引
# 求左侧第一个≥h[i]的奶牛位置
for i in range(N):
    while stack and cows[stack[-1]] < cows[i]:
        stack.pop()

    if stack:
        left_bound[i] = stack[-1]

    stack.append(i)

stack = []  # 清空栈以供寻找右边界使用

# 求右侧第一个≤h[i]的奶牛位
for i in range(N-1, -1, -1):
    while stack and cows[stack[-1]] > cows[i]:
        stack.pop()

    if stack:
        right_bound[i] = stack[-1]

    stack.append(i)

ans = 0

for i in range(N):  # 枚举右端点 B寻找 A，更新 ans
    for j in range(left_bound[i] + 1, i):
        if right_bound[j] > i:
            ans = max(ans, i - j + 1)
            break
print(ans)
```

代码运行截图

![image-20240517214251054](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240517214251054.png)

### 2. 学习总结和收获

Easy的两道题很easy，但是后边就傻眼了。上周因为赶ddl没有及时做月考题，这块没好好学，需要的变量一多脑子里就先乱了，估计撑死AC3/4（只求期末能3保底orz）。

以及怎么这么快就要期末了（？？？？？？）

## week14

Assignment #F: All-Killed 满分

Updated 1844 GMT+8 May 20, 2024

2024 spring, Complied by 靳咏歌 城市与环境学院

**说明：**

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted），填写到下面作业模版中（推荐使用 typora [https://typoraio.cn](https://typoraio.cn/) ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、"作业评论"区有上传的md或者doc附件。

3）如果不能在截止前提交作业，请写明原因。

**编程环境**

操作系统：Windows 11

Python编程环境：Spyder IDE 5.4.3（conda）, Python 3.11.5 64-bit | Qt 5.15.2 | PyQt5 5.15.7

### 22485: 升空的焰火，从侧面看

http://cs101.openjudge.cn/practice/22485/

思路：利用字典建立节点关系，然后对每层的节点进行搜索，留下最右边的节点

代码

```python
# 
from collections import deque

def right_view(n, tree):
    queue = deque([(1, tree[1])])
    right_view = []

    while queue:
        level_size = len(queue) #每次循环对应一层节点
        for i in range(level_size): 
            node, children = queue.popleft()
            if children[0] != -1: #有子节点，加入queue等待下一层搜索
                queue.append((children[0], tree[children[0]]))
            if children[1] != -1:
                queue.append((children[1], tree[children[1]]))
        right_view.append(node)

    return right_view

n = int(input())
tree = {1: [-1, -1] for _ in range(n+1)}
for i in range(n):
    left, right = map(int, input().split())
    tree[i+1] = [left, right]

result = right_view(n, tree)
print(' '.join(map(str, result)))
```

代码运行截图 

![image-20240525184902740](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525184902740.png)

### 28203:【模板】单调栈

http://cs101.openjudge.cn/practice/28203/

思路：单调栈

代码

```python
# 
n=int(input())
nlist=list(map(int,input().split()))
stack=[]

for i in range(n):
    while stack and nlist[stack[-1]] < nlist[i]:
        nlist[stack.pop()]=i+1 #索引从0开始，所以+1和“第几个”对应
    stack.append(i) #stack中存储索引位置
while stack:#最后一个元素，之后0个数比它大
    nlist[stack[-1]]=0 
    stack.pop()
    
print(*nlist)
```

代码运行截图

![image-20240525190154839](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525190154839.png)

### 09202: 舰队、海域出击！

http://cs101.openjudge.cn/practice/09202/

思路：

代码

```python
# 
from collections import deque
def topo_sort(graph):
    in_degree={u:0 for u in range(1,N+1)} #记录入度
    for u in graph:
        for v in graph[u]:
            in_degree[v]+=1
    q=deque([u for u in in_degree if in_degree[u]==0]) #从入度为0的开始
    topo_order=[]
    while q:
        u=q.popleft()
        topo_order.append(u)
        for v in graph[u]:
            in_degree[v]-=1 #将相连点的入度-1
            if in_degree[v]==0:
                q.append(v)
    if len(topo_order)!=len(graph):
        return 'Yes'
    return 'No' 

T=int(input())
for t in range(T):
    N,M=map(int,input().split())
    Map={i:[] for i in range(1,N+1)}
    for m in range(M):
        x,y=map(int,input().split())
        Map[x].append(y)
    print(topo_sort(Map))
```

代码运行截图 

![image-20240525193345333](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525193345333.png)

### 04135: 月度开销

http://cs101.openjudge.cn/practice/04135/

思路：

代码

```python
# 
n,m = map(int, input().split())
expenditure = []
for _ in range(n):
    expenditure.append(int(input()))

def check(x):
    num, s = 1, 0
    for i in range(n):
        if s + expenditure[i] > x:
            s = expenditure[i]
            num += 1
        else:
            s += expenditure[i]
    
    return [False, True][num > m]

lo = max(expenditure)

hi = sum(expenditure) + 1
ans = 1
while lo < hi:
    mid = (lo + hi) // 2
    if check(mid):      # 返回True，是因为num>m，是确定不合适
        lo = mid + 1    # 所以lo可以置为 mid + 1。
    else:
        ans = mid    # 如果num==m, mid可能是答案
        hi = mid

print(ans)
```

代码运行截图

![image-20240525195634564](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525195634564.png)

### 07735: 道路

http://cs101.openjudge.cn/practice/07735/

思路：

代码

```python
# 
import heapq

def dijkstra(g):
    while pq:
        dist,node,fee = heapq.heappop(pq)
        if node == n-1 :
            return dist
        for nei,w,f in g[node]:
            n_dist = dist + w
            n_fee = fee + f
            if n_fee <= k:
                dists[nei] = n_dist
                heapq.heappush(pq,(n_dist,nei,n_fee))
    return -1

k,n,r = int(input()),int(input()),int(input())
g = [[] for _ in range(n)]
for i in range(r):
    s,d,l,t = map(int,input().split())
    g[s-1].append((d-1,l,t)) #node,dist,fee

pq = [(0,0,0)] #dist,node,fee
dists = [float('inf')] * n
dists[0] = 0
spend = 0

result = dijkstra(g)
print(result)
```

代码运行截图 

![image-20240525201312292](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525201312292.png)

### 01182: 食物链

http://cs101.openjudge.cn/practice/01182/

思路：

代码

```python
class DisjointSet:
    def __init__(self, n):
        #设[1,n] 区间表示同类，[n+1,2*n]表示x吃的动物，[2*n+1,3*n]表示吃x的动物。
        self.parent = [i for i in range(3 * n + 1)] # 每个动物有三种可能的类型，用 3 * n 来表示每种类型的并查集
        self.rank = [0] * (3 * n + 1)

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu == pv:
            return False
        if self.rank[pu] > self.rank[pv]:
            self.parent[pv] = pu
        elif self.rank[pu] < self.rank[pv]:
            self.parent[pu] = pv
        else:
            self.parent[pv] = pu
            self.rank[pu] += 1
        return True


def is_valid(n, k, statements):
    dsu = DisjointSet(n)

    def find_disjoint_set(x):
        if x > n:
            return False
        return True

    false_count = 0
    for d, x, y in statements:
        if not find_disjoint_set(x) or not find_disjoint_set(y):
            false_count += 1
            continue
        if d == 1:  # X and Y are of the same type
            if dsu.find(x) == dsu.find(y + n) or dsu.find(x) == dsu.find(y + 2 * n):
                false_count += 1
            else:
                dsu.union(x, y)
                dsu.union(x + n, y + n)
                dsu.union(x + 2 * n, y + 2 * n)
        else:  # X eats Y
            if dsu.find(x) == dsu.find(y) or dsu.find(x + 2*n) == dsu.find(y):
                false_count += 1
            else: #[1,n] 区间表示同类，[n+1,2*n]表示x吃的动物，[2*n+1,3*n]表示吃x的动物
                dsu.union(x + n, y)
                dsu.union(x, y + 2 * n)
                dsu.union(x + 2 * n, y + n)

    return false_count


if __name__ == "__main__":
    N, K = map(int, input().split())
    statements = []
    for _ in range(K):
        D, X, Y = map(int, input().split())
        statements.append((D, X, Y))
    result = is_valid(N, K, statements)
    print(result)
```



```python
# 
def find(x):	# 并查集查询
    if p[x] == x:
        return x
    else:
        p[x] = find(p[x])	# 父节点设为根节点。目的是路径压缩。
        return p[x]

n,k = map(int, input().split())

p = [0]*(3*n + 1)
for i in range(3*n+1):	#并查集初始化
    p[i] = i

ans = 0
for _ in range(k):
    a,x,y = map(int, input().split())
    if x>n or y>n:
        ans += 1; continue
    
    if a==1:
        if find(x+n)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        
        # 合并
        p[find(x)] = find(y)				
        p[find(x+n)] = find(y+n)
        p[find(x+2*n)] = find(y+2*n)
    else:
        if find(x)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        p[find(x+n)] = find(y)
        p[find(y+2*n)] = find(x)
        p[find(x+2*n)] = find(y+n)

print(ans)
```

代码运行截图 

![image-20240525201525025](C:\Users\靳咏歌\AppData\Roaming\Typora\typora-user-images\image-20240525201525025.png)

## 2. 学习总结和收获

有些算法还是不熟悉……机考遇到就寄了。很多东西清楚原理，但是自己写代码就写不出来，思路连贯不上，必须得看题解什么样。这学期觉得自己时间很紧张，用在数算上的不多，看到群里大佬们发的整理感受到了很大的差距，只能趁最后这几天多看看（感谢大佬们的整理），希望能在考场上对上号。稀里糊涂就要期末了，以前的期望是AC保3冲4，现在感觉是保2冲3了（只能说大三不是那么需要绩点，这种想法让我提不起劲，现在的目标是及格拿个不难看的分数……）
